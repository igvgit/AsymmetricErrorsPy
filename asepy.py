# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _asepy
else:
    import _asepy

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _asepy.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _asepy.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _asepy.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _asepy.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _asepy.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _asepy.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _asepy.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _asepy.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _asepy.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _asepy.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _asepy.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _asepy.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _asepy.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _asepy.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _asepy.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _asepy.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _asepy:
_asepy.SwigPyIterator_swigregister(SwigPyIterator)

class string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def length(self) -> "std::basic_string< char >::size_type":
        return _asepy.string_length(self)

    def max_size(self) -> "std::basic_string< char >::size_type":
        return _asepy.string_max_size(self)

    def capacity(self) -> "std::basic_string< char >::size_type":
        return _asepy.string_capacity(self)

    def reserve(self, __res_arg: "std::basic_string< char >::size_type"=0) -> "void":
        return _asepy.string_reserve(self, __res_arg)

    def copy(self, __s: "char *", __n: "std::basic_string< char >::size_type", __pos: "std::basic_string< char >::size_type"=0) -> "std::basic_string< char >::size_type":
        return _asepy.string_copy(self, __s, __n, __pos)

    def c_str(self) -> "char const *":
        return _asepy.string_c_str(self)

    def find(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_find(self, *args)

    def rfind(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_rfind(self, *args)

    def find_first_of(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_find_first_of(self, *args)

    def find_last_of(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_find_last_of(self, *args)

    def find_first_not_of(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_find_first_not_of(self, *args)

    def find_last_not_of(self, *args) -> "std::basic_string< char >::size_type":
        return _asepy.string_find_last_not_of(self, *args)

    def substr(self, *args) -> "std::basic_string< char >":
        return _asepy.string_substr(self, *args)

    def empty(self) -> "bool":
        return _asepy.string_empty(self)

    def size(self) -> "std::basic_string< char >::size_type":
        return _asepy.string_size(self)

    def swap(self, v: "string") -> "void":
        return _asepy.string_swap(self, v)

    def begin(self) -> "std::basic_string< char >::iterator":
        return _asepy.string_begin(self)

    def end(self) -> "std::basic_string< char >::iterator":
        return _asepy.string_end(self)

    def rbegin(self) -> "std::basic_string< char >::reverse_iterator":
        return _asepy.string_rbegin(self)

    def rend(self) -> "std::basic_string< char >::reverse_iterator":
        return _asepy.string_rend(self)

    def get_allocator(self) -> "std::basic_string< char >::allocator_type":
        return _asepy.string_get_allocator(self)

    def erase(self, *args) -> "std::basic_string< char >::iterator":
        return _asepy.string_erase(self, *args)

    def __init__(self, *args):
        _asepy.string_swiginit(self, _asepy.new_string(*args))

    def assign(self, *args) -> "void":
        return _asepy.string_assign(self, *args)

    def resize(self, *args) -> "void":
        return _asepy.string_resize(self, *args)

    def iterator(self) -> "swig::SwigPyIterator *":
        return _asepy.string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _asepy.string___nonzero__(self)

    def __bool__(self) -> "bool":
        return _asepy.string___bool__(self)

    def __len__(self) -> "std::basic_string< char >::size_type":
        return _asepy.string___len__(self)

    def __getslice__(self, i: "std::basic_string< char >::difference_type", j: "std::basic_string< char >::difference_type") -> "std::basic_string< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _asepy.string___setslice__(self, *args)

    def __delslice__(self, i: "std::basic_string< char >::difference_type", j: "std::basic_string< char >::difference_type") -> "void":
        return _asepy.string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _asepy.string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::basic_string< char >::value_type":
        return _asepy.string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _asepy.string___setitem__(self, *args)

    def insert(self, *args) -> "void":
        return _asepy.string_insert(self, *args)

    def replace(self, *args) -> "std::basic_string< char > &":
        return _asepy.string_replace(self, *args)

    def __iadd__(self, v: "string") -> "std::basic_string< char > &":
        return _asepy.string___iadd__(self, v)

    def __add__(self, v: "string") -> "std::basic_string< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.string___add__(self, v)

    def __radd__(self, v: "string") -> "std::basic_string< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.string___radd__(self, v)

    def __str__(self) -> "std::basic_string< char,std::char_traits< char >,std::allocator< char > >":
        return _asepy.string___str__(self)

    def __rlshift__(self, out: "ostream") -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.string___rlshift__(self, out)

    def __eq__(self, v: "string") -> "bool":
        return _asepy.string___eq__(self, v)

    def __ne__(self, v: "string") -> "bool":
        return _asepy.string___ne__(self, v)

    def __gt__(self, v: "string") -> "bool":
        return _asepy.string___gt__(self, v)

    def __lt__(self, v: "string") -> "bool":
        return _asepy.string___lt__(self, v)

    def __ge__(self, v: "string") -> "bool":
        return _asepy.string___ge__(self, v)

    def __le__(self, v: "string") -> "bool":
        return _asepy.string___le__(self, v)
    __swig_destroy__ = _asepy.delete_string

# Register string in _asepy:
_asepy.string_swigregister(string)
cvar = _asepy.cvar
string.npos = _asepy.cvar.string_npos

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _asepy.ios_base_erase_event
    imbue_event = _asepy.ios_base_imbue_event
    copyfmt_event = _asepy.ios_base_copyfmt_event

    def register_callback(self, __fn: "std::ios_base::event_callback", __index: "int") -> "void":
        return _asepy.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args) -> "std::ios_base::fmtflags":
        return _asepy.ios_base_flags(self, *args)

    def setf(self, *args) -> "std::ios_base::fmtflags":
        return _asepy.ios_base_setf(self, *args)

    def unsetf(self, __mask: "std::ios_base::fmtflags") -> "void":
        return _asepy.ios_base_unsetf(self, __mask)

    def precision(self, *args) -> "std::streamsize":
        return _asepy.ios_base_precision(self, *args)

    def width(self, *args) -> "std::streamsize":
        return _asepy.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync: "bool"=True) -> "bool":
        return _asepy.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc: "std::locale const &") -> "std::locale":
        return _asepy.ios_base_imbue(self, __loc)

    def getloc(self) -> "std::locale":
        return _asepy.ios_base_getloc(self)

    @staticmethod
    def xalloc() -> "int":
        return _asepy.ios_base_xalloc()

    def iword(self, __ix: "int") -> "long &":
        return _asepy.ios_base_iword(self, __ix)

    def pword(self, __ix: "int") -> "void *&":
        return _asepy.ios_base_pword(self, __ix)
    __swig_destroy__ = _asepy.delete_ios_base

# Register ios_base in _asepy:
_asepy.ios_base_swigregister(ios_base)
ios_base.boolalpha = _asepy.cvar.ios_base_boolalpha
ios_base.dec = _asepy.cvar.ios_base_dec
ios_base.fixed = _asepy.cvar.ios_base_fixed
ios_base.hex = _asepy.cvar.ios_base_hex
ios_base.internal = _asepy.cvar.ios_base_internal
ios_base.left = _asepy.cvar.ios_base_left
ios_base.oct = _asepy.cvar.ios_base_oct
ios_base.right = _asepy.cvar.ios_base_right
ios_base.scientific = _asepy.cvar.ios_base_scientific
ios_base.showbase = _asepy.cvar.ios_base_showbase
ios_base.showpoint = _asepy.cvar.ios_base_showpoint
ios_base.showpos = _asepy.cvar.ios_base_showpos
ios_base.skipws = _asepy.cvar.ios_base_skipws
ios_base.unitbuf = _asepy.cvar.ios_base_unitbuf
ios_base.uppercase = _asepy.cvar.ios_base_uppercase
ios_base.adjustfield = _asepy.cvar.ios_base_adjustfield
ios_base.basefield = _asepy.cvar.ios_base_basefield
ios_base.floatfield = _asepy.cvar.ios_base_floatfield
ios_base.badbit = _asepy.cvar.ios_base_badbit
ios_base.eofbit = _asepy.cvar.ios_base_eofbit
ios_base.failbit = _asepy.cvar.ios_base_failbit
ios_base.goodbit = _asepy.cvar.ios_base_goodbit
ios_base.app = _asepy.cvar.ios_base_app
ios_base.ate = _asepy.cvar.ios_base_ate
ios_base.binary = _asepy.cvar.ios_base_binary
ios_base.ios_base_in = _asepy.cvar.ios_base_ios_base_in
ios_base.out = _asepy.cvar.ios_base_out
ios_base.trunc = _asepy.cvar.ios_base_trunc
ios_base.beg = _asepy.cvar.ios_base_beg
ios_base.cur = _asepy.cvar.ios_base_cur
ios_base.end = _asepy.cvar.ios_base_end

def ios_base_sync_with_stdio(__sync: "bool"=True) -> "bool":
    return _asepy.ios_base_sync_with_stdio(__sync)

def ios_base_xalloc() -> "int":
    return _asepy.ios_base_xalloc()

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self) -> "std::ios_base::iostate":
        return _asepy.ios_rdstate(self)

    def clear(self, *args) -> "void":
        return _asepy.ios_clear(self, *args)

    def setstate(self, __state: "std::ios_base::iostate") -> "void":
        return _asepy.ios_setstate(self, __state)

    def good(self) -> "bool":
        return _asepy.ios_good(self)

    def eof(self) -> "bool":
        return _asepy.ios_eof(self)

    def fail(self) -> "bool":
        return _asepy.ios_fail(self)

    def bad(self) -> "bool":
        return _asepy.ios_bad(self)

    def exceptions(self, *args) -> "void":
        return _asepy.ios_exceptions(self, *args)

    def __init__(self, __sb: "streambuf"):
        _asepy.ios_swiginit(self, _asepy.new_ios(__sb))
    __swig_destroy__ = _asepy.delete_ios

    def tie(self, *args) -> "std::basic_ostream< char,std::char_traits< char > > *":
        return _asepy.ios_tie(self, *args)

    def rdbuf(self, *args) -> "std::basic_streambuf< char,std::char_traits< char > > *":
        return _asepy.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs: "ios") -> "std::basic_ios< char > &":
        return _asepy.ios_copyfmt(self, __rhs)

    def fill(self, *args) -> "std::basic_ios< char >::char_type":
        return _asepy.ios_fill(self, *args)

    def imbue(self, __loc: "std::locale const &") -> "std::locale":
        return _asepy.ios_imbue(self, __loc)

    def narrow(self, __c: "std::basic_ios< char >::char_type", __dfault: "char") -> "char":
        return _asepy.ios_narrow(self, __c, __dfault)

    def widen(self, __c: "char") -> "std::basic_ios< char >::char_type":
        return _asepy.ios_widen(self, __c)

# Register ios in _asepy:
_asepy.ios_swigregister(ios)

class streambuf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_streambuf

    def pubimbue(self, __loc: "std::locale const &") -> "std::locale":
        return _asepy.streambuf_pubimbue(self, __loc)

    def getloc(self) -> "std::locale":
        return _asepy.streambuf_getloc(self)

    def pubsetbuf(self, __s: "std::basic_streambuf< char >::char_type *", __n: "std::streamsize") -> "std::basic_streambuf< char,std::char_traits< char > > *":
        return _asepy.streambuf_pubsetbuf(self, __s, __n)

    def pubseekoff(self, *args) -> "std::basic_streambuf< char >::pos_type":
        return _asepy.streambuf_pubseekoff(self, *args)

    def pubseekpos(self, *args) -> "std::basic_streambuf< char >::pos_type":
        return _asepy.streambuf_pubseekpos(self, *args)

    def pubsync(self) -> "int":
        return _asepy.streambuf_pubsync(self)

    def in_avail(self) -> "std::streamsize":
        return _asepy.streambuf_in_avail(self)

    def snextc(self) -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_snextc(self)

    def sbumpc(self) -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_sbumpc(self)

    def sgetc(self) -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_sgetc(self)

    def sgetn(self, __s: "std::basic_streambuf< char >::char_type *", __n: "std::streamsize") -> "std::streamsize":
        return _asepy.streambuf_sgetn(self, __s, __n)

    def sputbackc(self, __c: "std::basic_streambuf< char >::char_type") -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_sputbackc(self, __c)

    def sungetc(self) -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_sungetc(self)

    def sputc(self, __c: "std::basic_streambuf< char >::char_type") -> "std::basic_streambuf< char >::int_type":
        return _asepy.streambuf_sputc(self, __c)

    def sputn(self, __s: "std::basic_streambuf< char >::char_type const *", __n: "std::streamsize") -> "std::streamsize":
        return _asepy.streambuf_sputn(self, __s, __n)

# Register streambuf in _asepy:
_asepy.streambuf_swigregister(streambuf)

class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb: "streambuf"):
        _asepy.ostream_swiginit(self, _asepy.new_ostream(__sb))
    __swig_destroy__ = _asepy.delete_ostream

    def __lshift__(self, *args) -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.ostream___lshift__(self, *args)

    def put(self, __c: "std::basic_ostream< char >::char_type") -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.ostream_put(self, __c)

    def write(self, __s: "std::basic_ostream< char >::char_type const *", __n: "std::streamsize") -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.ostream_write(self, __s, __n)

    def flush(self) -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.ostream_flush(self)

    def tellp(self) -> "std::basic_ostream< char >::pos_type":
        return _asepy.ostream_tellp(self)

    def seekp(self, *args) -> "std::basic_ostream< char,std::char_traits< char > > &":
        return _asepy.ostream_seekp(self, *args)

# Register ostream in _asepy:
_asepy.ostream_swigregister(ostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb: "streambuf"):
        _asepy.istream_swiginit(self, _asepy.new_istream(__sb))
    __swig_destroy__ = _asepy.delete_istream

    def __rshift__(self, *args) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream___rshift__(self, *args)

    def gcount(self) -> "std::streamsize":
        return _asepy.istream_gcount(self)

    def get(self, *args) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_get(self, *args)

    def getline(self, *args) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_getline(self, *args)

    def ignore(self, *args) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_ignore(self, *args)

    def peek(self) -> "std::basic_istream< char >::int_type":
        return _asepy.istream_peek(self)

    def read(self, __s: "std::basic_istream< char >::char_type *", __n: "std::streamsize") -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_read(self, __s, __n)

    def readsome(self, __s: "std::basic_istream< char >::char_type *", __n: "std::streamsize") -> "std::streamsize":
        return _asepy.istream_readsome(self, __s, __n)

    def putback(self, __c: "std::basic_istream< char >::char_type") -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_putback(self, __c)

    def unget(self) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_unget(self)

    def sync(self) -> "int":
        return _asepy.istream_sync(self)

    def tellg(self) -> "std::basic_istream< char >::pos_type":
        return _asepy.istream_tellg(self)

    def seekg(self, *args) -> "std::basic_istream< char,std::char_traits< char > > &":
        return _asepy.istream_seekg(self, *args)

# Register istream in _asepy:
_asepy.istream_swigregister(istream)

class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb: "streambuf"):
        _asepy.iostream_swiginit(self, _asepy.new_iostream(__sb))
    __swig_destroy__ = _asepy.delete_iostream

# Register iostream in _asepy:
_asepy.iostream_swigregister(iostream)

endl_cb_ptr = _asepy.endl_cb_ptr
endl = _asepy.endl
ends_cb_ptr = _asepy.ends_cb_ptr
ends = _asepy.ends
flush_cb_ptr = _asepy.flush_cb_ptr
flush = _asepy.flush
class istringstream(istream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.istringstream_swiginit(self, _asepy.new_istringstream(*args))
    __swig_destroy__ = _asepy.delete_istringstream

    def rdbuf(self) -> "std::basic_stringbuf< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.istringstream_rdbuf(self)

    def str(self, *args) -> "void":
        return _asepy.istringstream_str(self, *args)

# Register istringstream in _asepy:
_asepy.istringstream_swigregister(istringstream)

class ostringstream(ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.ostringstream_swiginit(self, _asepy.new_ostringstream(*args))
    __swig_destroy__ = _asepy.delete_ostringstream

    def rdbuf(self) -> "std::basic_stringbuf< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.ostringstream_rdbuf(self)

    def str(self) -> "std::basic_string< char,std::char_traits< char >,std::allocator< char > >":
        return _asepy.ostringstream_str(self)

# Register ostringstream in _asepy:
_asepy.ostringstream_swigregister(ostringstream)

class stringstream(iostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.stringstream_swiginit(self, _asepy.new_stringstream(*args))
    __swig_destroy__ = _asepy.delete_stringstream

    def rdbuf(self) -> "std::basic_stringbuf< char,std::char_traits< char >,std::allocator< char > > *":
        return _asepy.stringstream_rdbuf(self)

    def str(self, *args) -> "void":
        return _asepy.stringstream_str(self, *args)

# Register stringstream in _asepy:
_asepy.stringstream_swigregister(stringstream)

class UIntDoublePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.UIntDoublePair_swiginit(self, _asepy.new_UIntDoublePair(*args))
    first = property(_asepy.UIntDoublePair_first_get, _asepy.UIntDoublePair_first_set)
    second = property(_asepy.UIntDoublePair_second_get, _asepy.UIntDoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _asepy.delete_UIntDoublePair

# Register UIntDoublePair in _asepy:
_asepy.UIntDoublePair_swigregister(UIntDoublePair)

class DoubleDoublePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.DoubleDoublePair_swiginit(self, _asepy.new_DoubleDoublePair(*args))
    first = property(_asepy.DoubleDoublePair_first_get, _asepy.DoubleDoublePair_first_set)
    second = property(_asepy.DoubleDoublePair_second_get, _asepy.DoubleDoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _asepy.delete_DoubleDoublePair

# Register DoubleDoublePair in _asepy:
_asepy.DoubleDoublePair_swigregister(DoubleDoublePair)

class BoolDoublePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.BoolDoublePair_swiginit(self, _asepy.new_BoolDoublePair(*args))
    first = property(_asepy.BoolDoublePair_first_get, _asepy.BoolDoublePair_first_set)
    second = property(_asepy.BoolDoublePair_second_get, _asepy.BoolDoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _asepy.delete_BoolDoublePair

# Register BoolDoublePair in _asepy:
_asepy.BoolDoublePair_swigregister(BoolDoublePair)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _asepy.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _asepy.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _asepy.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _asepy.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _asepy.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _asepy.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _asepy.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _asepy.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _asepy.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _asepy.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _asepy.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _asepy.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _asepy.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _asepy.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _asepy.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _asepy.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _asepy.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _asepy.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _asepy.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _asepy.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _asepy.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _asepy.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _asepy.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _asepy.DoubleVector_swiginit(self, _asepy.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _asepy.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _asepy.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _asepy.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _asepy.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _asepy.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _asepy.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _asepy.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _asepy.DoubleVector_capacity(self)
    __swig_destroy__ = _asepy.delete_DoubleVector

# Register DoubleVector in _asepy:
_asepy.DoubleVector_swigregister(DoubleVector)

class PyFunctor1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, callable: "PyObject *"):
        _asepy.PyFunctor1_swiginit(self, _asepy.new_PyFunctor1(callable))
    __swig_destroy__ = _asepy.delete_PyFunctor1

    def __call__(self, x_in: "double const") -> "double":
        return _asepy.PyFunctor1___call__(self, x_in)

    def findRoot(self, rhs: "double const", xmin: "double const", xmax: "double const", tol: "double"=0.0) -> "std::pair< bool,double >":
        return _asepy.PyFunctor1_findRoot(self, rhs, xmin, xmax, tol)

    def findMinimum(self, xleft: "double const", xmiddle: "double const", xright: "double const", tol: "double"=0.0) -> "std::pair< bool,double >":
        return _asepy.PyFunctor1_findMinimum(self, xleft, xmiddle, xright, tol)

    def findMaximum(self, xleft: "double const", xmiddle: "double const", xright: "double const", tol: "double"=0.0) -> "std::pair< bool,double >":
        return _asepy.PyFunctor1_findMaximum(self, xleft, xmiddle, xright, tol)

# Register PyFunctor1 in _asepy:
_asepy.PyFunctor1_swigregister(PyFunctor1)

class AbsRNG(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_AbsRNG

    def __call__(self) -> "double":
        return _asepy.AbsRNG___call__(self)

    def generate(self, npoints: "unsigned int const") -> "std::vector< double,std::allocator< double > >":
        return _asepy.AbsRNG_generate(self, npoints)

# Register AbsRNG in _asepy:
_asepy.AbsRNG_swigregister(AbsRNG)

class AbsDistributionModel1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_AbsDistributionModel1D

    def clone(self) -> "ase::AbsDistributionModel1D *":
        return _asepy.AbsDistributionModel1D_clone(self)

    def density(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_density(self, x)

    def isDensityContinuous(self) -> "bool":
        return _asepy.AbsDistributionModel1D_isDensityContinuous(self)

    def isNonNegative(self) -> "bool":
        return _asepy.AbsDistributionModel1D_isNonNegative(self)

    def isUnimodal(self) -> "bool":
        return _asepy.AbsDistributionModel1D_isUnimodal(self)

    def densityDerivative(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_densityDerivative(self, x)

    def cdf(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_cdf(self, x)

    def exceedance(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_exceedance(self, x)

    def quantile(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_quantile(self, x)

    def invExceedance(self, x: "double") -> "double":
        return _asepy.AbsDistributionModel1D_invExceedance(self, x)

    def cumulant(self, n: "unsigned int") -> "double":
        return _asepy.AbsDistributionModel1D_cumulant(self, n)

    def mode(self) -> "double":
        return _asepy.AbsDistributionModel1D_mode(self)

    def descentDelta(self, isToTheRight: "bool", deltaLnL: "double"=0.5) -> "double":
        return _asepy.AbsDistributionModel1D_descentDelta(self, isToTheRight, deltaLnL)

    def classname(self) -> "std::string":
        return _asepy.AbsDistributionModel1D_classname(self)

    def random(self, gen: "AbsRNG") -> "double":
        return _asepy.AbsDistributionModel1D_random(self, gen)

    def qWidth(self) -> "double":
        return _asepy.AbsDistributionModel1D_qWidth(self)

    def qAsymmetry(self) -> "double":
        return _asepy.AbsDistributionModel1D_qAsymmetry(self)

    def generate(self, g: "AbsRNG", npoints: "unsigned int const") -> "std::vector< double,std::allocator< double > >":
        return _asepy.AbsDistributionModel1D_generate(self, g, npoints)

# Register AbsDistributionModel1D in _asepy:
_asepy.AbsDistributionModel1D_swigregister(AbsDistributionModel1D)

class AbsLocationScaleFamily(AbsDistributionModel1D):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def clone(self) -> "ase::AbsLocationScaleFamily *":
        return _asepy.AbsLocationScaleFamily_clone(self)
    __swig_destroy__ = _asepy.delete_AbsLocationScaleFamily

    def location(self) -> "double":
        return _asepy.AbsLocationScaleFamily_location(self)

    def scale(self) -> "double":
        return _asepy.AbsLocationScaleFamily_scale(self)

    def setLocation(self, loc: "double const") -> "void":
        return _asepy.AbsLocationScaleFamily_setLocation(self, loc)

    def setScale(self, s: "double const") -> "void":
        return _asepy.AbsLocationScaleFamily_setScale(self, s)

    def density(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_density(self, x)

    def densityDerivative(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_densityDerivative(self, x)

    def cdf(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_cdf(self, x)

    def exceedance(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_exceedance(self, x)

    def quantile(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_quantile(self, x)

    def invExceedance(self, x: "double const") -> "double":
        return _asepy.AbsLocationScaleFamily_invExceedance(self, x)

    def cumulant(self, n: "unsigned int const") -> "double":
        return _asepy.AbsLocationScaleFamily_cumulant(self, n)

    def mode(self) -> "double":
        return _asepy.AbsLocationScaleFamily_mode(self)

    def descentDelta(self, isToTheRight: "bool", deltaLnL: "double"=0.5) -> "double":
        return _asepy.AbsLocationScaleFamily_descentDelta(self, isToTheRight, deltaLnL)

    def random(self, gen: "AbsRNG") -> "double":
        return _asepy.AbsLocationScaleFamily_random(self, gen)

    def qWidth(self) -> "double":
        return _asepy.AbsLocationScaleFamily_qWidth(self)

    def qAsymmetry(self) -> "double":
        return _asepy.AbsLocationScaleFamily_qAsymmetry(self)

    def classname(self) -> "std::string":
        return _asepy.AbsLocationScaleFamily_classname(self)

# Register AbsLocationScaleFamily in _asepy:
_asepy.AbsLocationScaleFamily_swigregister(AbsLocationScaleFamily)

class DensityFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.DensityFunctor1D_swiginit(self, _asepy.new_DensityFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DensityFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_DensityFunctor1D

# Register DensityFunctor1D in _asepy:
_asepy.DensityFunctor1D_swigregister(DensityFunctor1D)

class DensityDerivativeFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.DensityDerivativeFunctor1D_swiginit(self, _asepy.new_DensityDerivativeFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DensityDerivativeFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_DensityDerivativeFunctor1D

# Register DensityDerivativeFunctor1D in _asepy:
_asepy.DensityDerivativeFunctor1D_swigregister(DensityDerivativeFunctor1D)

class ShiftedDensityFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D", shift: "double const", flipSign: "bool const"=False):
        _asepy.ShiftedDensityFunctor1D_swiginit(self, _asepy.new_ShiftedDensityFunctor1D(fcn, shift, flipSign))

    def __call__(self, x: "double const") -> "double":
        return _asepy.ShiftedDensityFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_ShiftedDensityFunctor1D

# Register ShiftedDensityFunctor1D in _asepy:
_asepy.ShiftedDensityFunctor1D_swigregister(ShiftedDensityFunctor1D)

class CdfFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.CdfFunctor1D_swiginit(self, _asepy.new_CdfFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.CdfFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_CdfFunctor1D

# Register CdfFunctor1D in _asepy:
_asepy.CdfFunctor1D_swigregister(CdfFunctor1D)

class ExceedanceFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.ExceedanceFunctor1D_swiginit(self, _asepy.new_ExceedanceFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.ExceedanceFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_ExceedanceFunctor1D

# Register ExceedanceFunctor1D in _asepy:
_asepy.ExceedanceFunctor1D_swigregister(ExceedanceFunctor1D)

class InvExceedanceFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.InvExceedanceFunctor1D_swiginit(self, _asepy.new_InvExceedanceFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.InvExceedanceFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_InvExceedanceFunctor1D

# Register InvExceedanceFunctor1D in _asepy:
_asepy.InvExceedanceFunctor1D_swigregister(InvExceedanceFunctor1D)

class QuantileFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.QuantileFunctor1D_swiginit(self, _asepy.new_QuantileFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.QuantileFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_QuantileFunctor1D

# Register QuantileFunctor1D in _asepy:
_asepy.QuantileFunctor1D_swigregister(QuantileFunctor1D)

class EntropyFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.EntropyFunctor1D_swiginit(self, _asepy.new_EntropyFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.EntropyFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_EntropyFunctor1D

# Register EntropyFunctor1D in _asepy:
_asepy.EntropyFunctor1D_swigregister(EntropyFunctor1D)

class LogDensityFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D"):
        _asepy.LogDensityFunctor1D_swiginit(self, _asepy.new_LogDensityFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.LogDensityFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_LogDensityFunctor1D

# Register LogDensityFunctor1D in _asepy:
_asepy.LogDensityFunctor1D_swigregister(LogDensityFunctor1D)

class MomentFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsDistributionModel1D", mu0: "double const", n: "unsigned int const"):
        _asepy.MomentFunctor1D_swiginit(self, _asepy.new_MomentFunctor1D(fcn, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.MomentFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_MomentFunctor1D

# Register MomentFunctor1D in _asepy:
_asepy.MomentFunctor1D_swigregister(MomentFunctor1D)

class RatioMomentFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcnNum: "AbsDistributionModel1D", fcnDenom: "AbsDistributionModel1D", mu0: "double const", n: "unsigned int const"):
        _asepy.RatioMomentFunctor1D_swiginit(self, _asepy.new_RatioMomentFunctor1D(fcnNum, fcnDenom, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.RatioMomentFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_RatioMomentFunctor1D

# Register RatioMomentFunctor1D in _asepy:
_asepy.RatioMomentFunctor1D_swigregister(RatioMomentFunctor1D)

class UnscaledCdfFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledCdfFunctor1D_swiginit(self, _asepy.new_UnscaledCdfFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledCdfFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledCdfFunctor1D

# Register UnscaledCdfFunctor1D in _asepy:
_asepy.UnscaledCdfFunctor1D_swigregister(UnscaledCdfFunctor1D)

class UnscaledExceedanceFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledExceedanceFunctor1D_swiginit(self, _asepy.new_UnscaledExceedanceFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledExceedanceFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledExceedanceFunctor1D

# Register UnscaledExceedanceFunctor1D in _asepy:
_asepy.UnscaledExceedanceFunctor1D_swigregister(UnscaledExceedanceFunctor1D)

class UnscaledQuantileFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledQuantileFunctor1D_swiginit(self, _asepy.new_UnscaledQuantileFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledQuantileFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledQuantileFunctor1D

# Register UnscaledQuantileFunctor1D in _asepy:
_asepy.UnscaledQuantileFunctor1D_swigregister(UnscaledQuantileFunctor1D)

class UnscaledInvExceedanceFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledInvExceedanceFunctor1D_swiginit(self, _asepy.new_UnscaledInvExceedanceFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledInvExceedanceFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledInvExceedanceFunctor1D

# Register UnscaledInvExceedanceFunctor1D in _asepy:
_asepy.UnscaledInvExceedanceFunctor1D_swigregister(UnscaledInvExceedanceFunctor1D)

class UnscaledDensityFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledDensityFunctor1D_swiginit(self, _asepy.new_UnscaledDensityFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledDensityFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledDensityFunctor1D

# Register UnscaledDensityFunctor1D in _asepy:
_asepy.UnscaledDensityFunctor1D_swigregister(UnscaledDensityFunctor1D)

class UnscaledDensityDerivativeFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledDensityDerivativeFunctor1D_swiginit(self, _asepy.new_UnscaledDensityDerivativeFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledDensityDerivativeFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledDensityDerivativeFunctor1D

# Register UnscaledDensityDerivativeFunctor1D in _asepy:
_asepy.UnscaledDensityDerivativeFunctor1D_swigregister(UnscaledDensityDerivativeFunctor1D)

class UnscaledMomentFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily", mu0: "double const", n: "unsigned int const"):
        _asepy.UnscaledMomentFunctor1D_swiginit(self, _asepy.new_UnscaledMomentFunctor1D(fcn, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledMomentFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledMomentFunctor1D

# Register UnscaledMomentFunctor1D in _asepy:
_asepy.UnscaledMomentFunctor1D_swigregister(UnscaledMomentFunctor1D)

class UnscaledEntropyFunctor1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLocationScaleFamily"):
        _asepy.UnscaledEntropyFunctor1D_swiginit(self, _asepy.new_UnscaledEntropyFunctor1D(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.UnscaledEntropyFunctor1D___call__(self, x)
    __swig_destroy__ = _asepy.delete_UnscaledEntropyFunctor1D

# Register UnscaledEntropyFunctor1D in _asepy:
_asepy.UnscaledEntropyFunctor1D_swigregister(UnscaledEntropyFunctor1D)

class NumericalConvolution(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m1: "AbsDistributionModel1D", m2: "AbsDistributionModel1D", nPt: "unsigned int", nIntervals: "unsigned int"=1):
        _asepy.NumericalConvolution_swiginit(self, _asepy.new_NumericalConvolution(m1, m2, nPt, nIntervals))

    def __call__(self, x: "double") -> "double":
        return _asepy.NumericalConvolution___call__(self, x)
    __swig_destroy__ = _asepy.delete_NumericalConvolution

# Register NumericalConvolution in _asepy:
_asepy.NumericalConvolution_swigregister(NumericalConvolution)

class GaussianConvolution(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m1: "AbsDistributionModel1D", mean: "double const", sigma: "double const", nPt: "unsigned int const"):
        _asepy.GaussianConvolution_swiginit(self, _asepy.new_GaussianConvolution(m1, mean, sigma, nPt))

    def __call__(self, x: "double const") -> "double":
        return _asepy.GaussianConvolution___call__(self, x)
    __swig_destroy__ = _asepy.delete_GaussianConvolution

# Register GaussianConvolution in _asepy:
_asepy.GaussianConvolution_swigregister(GaussianConvolution)

class FunctorTimesShiftedXHelperNConv(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "NumericalConvolution", mu0: "double const", n: "unsigned int const"):
        _asepy.FunctorTimesShiftedXHelperNConv_swiginit(self, _asepy.new_FunctorTimesShiftedXHelperNConv(fcn, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.FunctorTimesShiftedXHelperNConv___call__(self, x)
    __swig_destroy__ = _asepy.delete_FunctorTimesShiftedXHelperNConv

# Register FunctorTimesShiftedXHelperNConv in _asepy:
_asepy.FunctorTimesShiftedXHelperNConv_swigregister(FunctorTimesShiftedXHelperNConv)

class FunctorTimesShiftedXHelperGConv(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "GaussianConvolution", mu0: "double const", n: "unsigned int const"):
        _asepy.FunctorTimesShiftedXHelperGConv_swiginit(self, _asepy.new_FunctorTimesShiftedXHelperGConv(fcn, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.FunctorTimesShiftedXHelperGConv___call__(self, x)
    __swig_destroy__ = _asepy.delete_FunctorTimesShiftedXHelperGConv

# Register FunctorTimesShiftedXHelperGConv in _asepy:
_asepy.FunctorTimesShiftedXHelperGConv_swigregister(FunctorTimesShiftedXHelperGConv)


def FunctorTimesShiftedX(*args) -> "ase::FunctorTimesShiftedXHelper< ase::GaussianConvolution >":
    return _asepy.FunctorTimesShiftedX(*args)
class FunctorTimesShiftedXRatioHelperNConv(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "NumericalConvolution", fcnDenom: "AbsDistributionModel1D", mu0: "double const", n: "unsigned int const"):
        _asepy.FunctorTimesShiftedXRatioHelperNConv_swiginit(self, _asepy.new_FunctorTimesShiftedXRatioHelperNConv(fcn, fcnDenom, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.FunctorTimesShiftedXRatioHelperNConv___call__(self, x)
    __swig_destroy__ = _asepy.delete_FunctorTimesShiftedXRatioHelperNConv

# Register FunctorTimesShiftedXRatioHelperNConv in _asepy:
_asepy.FunctorTimesShiftedXRatioHelperNConv_swigregister(FunctorTimesShiftedXRatioHelperNConv)

class FunctorTimesShiftedXRatioHelperGConv(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "GaussianConvolution", fcnDenom: "AbsDistributionModel1D", mu0: "double const", n: "unsigned int const"):
        _asepy.FunctorTimesShiftedXRatioHelperGConv_swiginit(self, _asepy.new_FunctorTimesShiftedXRatioHelperGConv(fcn, fcnDenom, mu0, n))

    def __call__(self, x: "double const") -> "double":
        return _asepy.FunctorTimesShiftedXRatioHelperGConv___call__(self, x)
    __swig_destroy__ = _asepy.delete_FunctorTimesShiftedXRatioHelperGConv

# Register FunctorTimesShiftedXRatioHelperGConv in _asepy:
_asepy.FunctorTimesShiftedXRatioHelperGConv_swigregister(FunctorTimesShiftedXRatioHelperGConv)


def FunctorTimesShiftedXRatio(*args) -> "ase::FunctorTimesShiftedXRatioHelper< ase::GaussianConvolution >":
    return _asepy.FunctorTimesShiftedXRatio(*args)
class GaussHermiteQuadrature(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, npoints: "unsigned int"):
        _asepy.GaussHermiteQuadrature_swiginit(self, _asepy.new_GaussHermiteQuadrature(npoints))

    def npoints(self) -> "unsigned int":
        return _asepy.GaussHermiteQuadrature_npoints(self)

    @staticmethod
    def isAllowed(npoints: "unsigned int") -> "bool":
        return _asepy.GaussHermiteQuadrature_isAllowed(npoints)

    @staticmethod
    def allowedNPonts() -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        return _asepy.GaussHermiteQuadrature_allowedNPonts()

    @staticmethod
    def minimalExactRule(polyDegree: "unsigned int") -> "unsigned int":
        return _asepy.GaussHermiteQuadrature_minimalExactRule(polyDegree)

    def integrateProb(self, *args) -> "double":
        return _asepy.GaussHermiteQuadrature_integrateProb(self, *args)

    def integrate(self, function: "PyFunctor1") -> "double":
        return _asepy.GaussHermiteQuadrature_integrate(self, function)
    __swig_destroy__ = _asepy.delete_GaussHermiteQuadrature

# Register GaussHermiteQuadrature in _asepy:
_asepy.GaussHermiteQuadrature_swigregister(GaussHermiteQuadrature)

def GaussHermiteQuadrature_isAllowed(npoints: "unsigned int") -> "bool":
    return _asepy.GaussHermiteQuadrature_isAllowed(npoints)

def GaussHermiteQuadrature_allowedNPonts() -> "std::vector< unsigned int,std::allocator< unsigned int > >":
    return _asepy.GaussHermiteQuadrature_allowedNPonts()

def GaussHermiteQuadrature_minimalExactRule(polyDegree: "unsigned int") -> "unsigned int":
    return _asepy.GaussHermiteQuadrature_minimalExactRule(polyDegree)


def factorial(n: "unsigned int") -> "unsigned long":
    return _asepy.factorial(n)

def ldfactorial(n: "unsigned int") -> "long double":
    return _asepy.ldfactorial(n)

def logfactorial(n: "unsigned long") -> "long double":
    return _asepy.logfactorial(n)

def solveQuadratic(*args) -> "unsigned int":
    return _asepy.solveQuadratic(*args)

def solveCubic(p: "double", q: "double", r: "double", v3: "double [3]") -> "unsigned int":
    return _asepy.solveCubic(p, q, r, v3)

def cubicMinimum01(f0: "double", d0: "double", f1: "double", d1: "double") -> "std::pair< double,double >":
    return _asepy.cubicMinimum01(f0, d0, f1, d1)

def cubicMaximum01(f0: "double", d0: "double", f1: "double", d1: "double") -> "std::pair< double,double >":
    return _asepy.cubicMaximum01(f0, d0, f1, d1)

def hermiteSeriesRoots(coeffs: "long double const *", degree: "unsigned int", a: "long double", b: "long double", roots: "long double *") -> "unsigned int":
    return _asepy.hermiteSeriesRoots(coeffs, degree, a, b, roots)

def linearValue(x0: "double", y0: "double", x1: "double", y1: "double", x: "double") -> "double":
    return _asepy.linearValue(x0, y0, x1, y1, x)
class Gaussian(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.Gaussian_isFullOPAT

    def __init__(self, *args):
        _asepy.Gaussian_swiginit(self, _asepy.new_Gaussian(*args))

    def clone(self) -> "ase::Gaussian *":
        return _asepy.Gaussian_clone(self)
    __swig_destroy__ = _asepy.delete_Gaussian

    def classname(self) -> "std::string":
        return _asepy.Gaussian_classname(self)

    def qWidth(self) -> "double":
        return _asepy.Gaussian_qWidth(self)

    def qAsymmetry(self) -> "double":
        return _asepy.Gaussian_qAsymmetry(self)

    def entropy(self) -> "double":
        return _asepy.Gaussian_entropy(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::Gaussian *":
        return _asepy.Gaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

# Register Gaussian in _asepy:
_asepy.Gaussian_swigregister(Gaussian)

def Gaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::Gaussian *":
    return _asepy.Gaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

class SymbetaDoubleIntegral(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymbetaDoubleIntegral_swiginit(self, _asepy.new_SymbetaDoubleIntegral(*args))

    def p(self) -> "unsigned int":
        return _asepy.SymbetaDoubleIntegral_p(self)

    def h(self) -> "double":
        return _asepy.SymbetaDoubleIntegral_h(self)

    def a(self) -> "double":
        return _asepy.SymbetaDoubleIntegral_a(self)

    def k(self) -> "double":
        return _asepy.SymbetaDoubleIntegral_k(self)

    def hasExtremum(self) -> "bool":
        return _asepy.SymbetaDoubleIntegral_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.SymbetaDoubleIntegral_isFlat(self)

    def extremum(self) -> "std::pair< double,double >":
        return _asepy.SymbetaDoubleIntegral_extremum(self)

    def __call__(self, x: "double const") -> "double":
        return _asepy.SymbetaDoubleIntegral___call__(self, x)

    def derivative(self, x: "double const") -> "double":
        return _asepy.SymbetaDoubleIntegral_derivative(self, x)

    def secondDerivative(self, x: "double const") -> "double":
        return _asepy.SymbetaDoubleIntegral_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "double const", x: "double const") -> "double":
        return _asepy.SymbetaDoubleIntegral_zoneContinuation(self, xZone, x)

    def inverse(self, y: "double const", solutions: "double [2]") -> "unsigned int":
        return _asepy.SymbetaDoubleIntegral_inverse(self, y, solutions)

    @staticmethod
    def fromSigmas(i_p: "unsigned int const", i_h: "double const", sigmaPlus: "double const", sigmaMinus: "double const", normalizeScale: "bool const"=False) -> "ase::SymbetaDoubleIntegral< double >":
        return _asepy.SymbetaDoubleIntegral_fromSigmas(i_p, i_h, sigmaPlus, sigmaMinus, normalizeScale)

    @staticmethod
    def minRNoExtremum(i_p: "unsigned int const", i_h: "double const") -> "double":
        return _asepy.SymbetaDoubleIntegral_minRNoExtremum(i_p, i_h)
    __swig_destroy__ = _asepy.delete_SymbetaDoubleIntegral

# Register SymbetaDoubleIntegral in _asepy:
_asepy.SymbetaDoubleIntegral_swigregister(SymbetaDoubleIntegral)

def SymbetaDoubleIntegral_fromSigmas(i_p: "unsigned int const", i_h: "double const", sigmaPlus: "double const", sigmaMinus: "double const", normalizeScale: "bool const"=False) -> "ase::SymbetaDoubleIntegral< double >":
    return _asepy.SymbetaDoubleIntegral_fromSigmas(i_p, i_h, sigmaPlus, sigmaMinus, normalizeScale)

def SymbetaDoubleIntegral_minRNoExtremum(i_p: "unsigned int const", i_h: "double const") -> "double":
    return _asepy.SymbetaDoubleIntegral_minRNoExtremum(i_p, i_h)

class SDIZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "SymbetaDoubleIntegral", xZone: "double const", fShift: "double const", power: "unsigned int const"):
        _asepy.SDIZoneFunctor_swiginit(self, _asepy.new_SDIZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SDIZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_SDIZoneFunctor

# Register SDIZoneFunctor in _asepy:
_asepy.SDIZoneFunctor_swigregister(SDIZoneFunctor)

class LDSymbetaDoubleIntegral(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.LDSymbetaDoubleIntegral_swiginit(self, _asepy.new_LDSymbetaDoubleIntegral(*args))

    def p(self) -> "unsigned int":
        return _asepy.LDSymbetaDoubleIntegral_p(self)

    def h(self) -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_h(self)

    def a(self) -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_a(self)

    def k(self) -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_k(self)

    def hasExtremum(self) -> "bool":
        return _asepy.LDSymbetaDoubleIntegral_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.LDSymbetaDoubleIntegral_isFlat(self)

    def extremum(self) -> "std::pair< long double,long double >":
        return _asepy.LDSymbetaDoubleIntegral_extremum(self)

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDSymbetaDoubleIntegral___call__(self, x)

    def derivative(self, x: "long double const") -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_derivative(self, x)

    def secondDerivative(self, x: "long double const") -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "long double const", x: "long double const") -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_zoneContinuation(self, xZone, x)

    def inverse(self, y: "long double const", solutions: "long double [2]") -> "unsigned int":
        return _asepy.LDSymbetaDoubleIntegral_inverse(self, y, solutions)

    @staticmethod
    def fromSigmas(i_p: "unsigned int const", i_h: "long double const", sigmaPlus: "long double const", sigmaMinus: "long double const", normalizeScale: "bool const"=False) -> "ase::SymbetaDoubleIntegral< long double >":
        return _asepy.LDSymbetaDoubleIntegral_fromSigmas(i_p, i_h, sigmaPlus, sigmaMinus, normalizeScale)

    @staticmethod
    def minRNoExtremum(i_p: "unsigned int const", i_h: "long double const") -> "long double":
        return _asepy.LDSymbetaDoubleIntegral_minRNoExtremum(i_p, i_h)
    __swig_destroy__ = _asepy.delete_LDSymbetaDoubleIntegral

# Register LDSymbetaDoubleIntegral in _asepy:
_asepy.LDSymbetaDoubleIntegral_swigregister(LDSymbetaDoubleIntegral)

def LDSymbetaDoubleIntegral_fromSigmas(i_p: "unsigned int const", i_h: "long double const", sigmaPlus: "long double const", sigmaMinus: "long double const", normalizeScale: "bool const"=False) -> "ase::SymbetaDoubleIntegral< long double >":
    return _asepy.LDSymbetaDoubleIntegral_fromSigmas(i_p, i_h, sigmaPlus, sigmaMinus, normalizeScale)

def LDSymbetaDoubleIntegral_minRNoExtremum(i_p: "unsigned int const", i_h: "long double const") -> "long double":
    return _asepy.LDSymbetaDoubleIntegral_minRNoExtremum(i_p, i_h)

class LDSDIZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "LDSymbetaDoubleIntegral", xZone: "long double const", fShift: "long double const", power: "unsigned int const"):
        _asepy.LDSDIZoneFunctor_swiginit(self, _asepy.new_LDSDIZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDSDIZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_LDSDIZoneFunctor

# Register LDSDIZoneFunctor in _asepy:
_asepy.LDSDIZoneFunctor_swigregister(LDSDIZoneFunctor)

class ParabolicRailwayCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_sigmaPlus: "double const", i_sigmaMinus: "double const", i_hleft: "double const", i_hright: "double const", scaleNorm: "double const"=1.0):
        _asepy.ParabolicRailwayCurve_swiginit(self, _asepy.new_ParabolicRailwayCurve(i_sigmaPlus, i_sigmaMinus, i_hleft, i_hright, scaleNorm))

    def hleft(self) -> "double":
        return _asepy.ParabolicRailwayCurve_hleft(self)

    def hright(self) -> "double":
        return _asepy.ParabolicRailwayCurve_hright(self)

    def sigmaPlus(self) -> "double":
        return _asepy.ParabolicRailwayCurve_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.ParabolicRailwayCurve_sigmaMinus(self)

    def hasExtremum(self) -> "bool":
        return _asepy.ParabolicRailwayCurve_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.ParabolicRailwayCurve_isFlat(self)

    def extremum(self) -> "std::pair< double,double >":
        return _asepy.ParabolicRailwayCurve_extremum(self)

    def __call__(self, x: "double const") -> "double":
        return _asepy.ParabolicRailwayCurve___call__(self, x)

    def derivative(self, x: "double const") -> "double":
        return _asepy.ParabolicRailwayCurve_derivative(self, x)

    def secondDerivative(self, x: "double const") -> "double":
        return _asepy.ParabolicRailwayCurve_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "double const", x: "double const") -> "double":
        return _asepy.ParabolicRailwayCurve_zoneContinuation(self, xZone, x)

    def inverse(self, y: "double const", solutions: "double [2]") -> "unsigned int":
        return _asepy.ParabolicRailwayCurve_inverse(self, y, solutions)
    __swig_destroy__ = _asepy.delete_ParabolicRailwayCurve

# Register ParabolicRailwayCurve in _asepy:
_asepy.ParabolicRailwayCurve_swigregister(ParabolicRailwayCurve)

class RailwayZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "ParabolicRailwayCurve", xZone: "double const", fShift: "double const", power: "unsigned int const"):
        _asepy.RailwayZoneFunctor_swiginit(self, _asepy.new_RailwayZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "double const") -> "double":
        return _asepy.RailwayZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_RailwayZoneFunctor

# Register RailwayZoneFunctor in _asepy:
_asepy.RailwayZoneFunctor_swigregister(RailwayZoneFunctor)

class LDParabolicRailwayCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_sigmaPlus: "long double const", i_sigmaMinus: "long double const", i_hleft: "long double const", i_hright: "long double const", scaleNorm: "long double const"=1.0):
        _asepy.LDParabolicRailwayCurve_swiginit(self, _asepy.new_LDParabolicRailwayCurve(i_sigmaPlus, i_sigmaMinus, i_hleft, i_hright, scaleNorm))

    def hleft(self) -> "long double":
        return _asepy.LDParabolicRailwayCurve_hleft(self)

    def hright(self) -> "long double":
        return _asepy.LDParabolicRailwayCurve_hright(self)

    def sigmaPlus(self) -> "long double":
        return _asepy.LDParabolicRailwayCurve_sigmaPlus(self)

    def sigmaMinus(self) -> "long double":
        return _asepy.LDParabolicRailwayCurve_sigmaMinus(self)

    def hasExtremum(self) -> "bool":
        return _asepy.LDParabolicRailwayCurve_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.LDParabolicRailwayCurve_isFlat(self)

    def extremum(self) -> "std::pair< long double,long double >":
        return _asepy.LDParabolicRailwayCurve_extremum(self)

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDParabolicRailwayCurve___call__(self, x)

    def derivative(self, x: "long double const") -> "long double":
        return _asepy.LDParabolicRailwayCurve_derivative(self, x)

    def secondDerivative(self, x: "long double const") -> "long double":
        return _asepy.LDParabolicRailwayCurve_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "long double const", x: "long double const") -> "long double":
        return _asepy.LDParabolicRailwayCurve_zoneContinuation(self, xZone, x)

    def inverse(self, y: "long double const", solutions: "long double [2]") -> "unsigned int":
        return _asepy.LDParabolicRailwayCurve_inverse(self, y, solutions)
    __swig_destroy__ = _asepy.delete_LDParabolicRailwayCurve

# Register LDParabolicRailwayCurve in _asepy:
_asepy.LDParabolicRailwayCurve_swigregister(LDParabolicRailwayCurve)

class LDRailwayZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "LDParabolicRailwayCurve", xZone: "long double const", fShift: "long double const", power: "unsigned int const"):
        _asepy.LDRailwayZoneFunctor_swiginit(self, _asepy.new_LDRailwayZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDRailwayZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_LDRailwayZoneFunctor

# Register LDRailwayZoneFunctor in _asepy:
_asepy.LDRailwayZoneFunctor_swigregister(LDRailwayZoneFunctor)

class SmoothDoubleCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_sigmaPlus: "double const", i_sigmaMinus: "double const", scaleNorm: "double const"=1.0):
        _asepy.SmoothDoubleCubic_swiginit(self, _asepy.new_SmoothDoubleCubic(i_sigmaPlus, i_sigmaMinus, scaleNorm))

    def sigmaPlus(self) -> "double":
        return _asepy.SmoothDoubleCubic_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.SmoothDoubleCubic_sigmaMinus(self)

    def hasExtremum(self) -> "bool":
        return _asepy.SmoothDoubleCubic_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.SmoothDoubleCubic_isFlat(self)

    def extremum(self) -> "std::pair< double,double >":
        return _asepy.SmoothDoubleCubic_extremum(self)

    def __call__(self, x: "double const") -> "double":
        return _asepy.SmoothDoubleCubic___call__(self, x)

    def derivative(self, x: "double const") -> "double":
        return _asepy.SmoothDoubleCubic_derivative(self, x)

    def secondDerivative(self, x: "double const") -> "double":
        return _asepy.SmoothDoubleCubic_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "double const", x: "double const") -> "double":
        return _asepy.SmoothDoubleCubic_zoneContinuation(self, xZone, x)

    def inverse(self, y: "double const", solutions: "double [2]") -> "unsigned int":
        return _asepy.SmoothDoubleCubic_inverse(self, y, solutions)
    __swig_destroy__ = _asepy.delete_SmoothDoubleCubic

# Register SmoothDoubleCubic in _asepy:
_asepy.SmoothDoubleCubic_swigregister(SmoothDoubleCubic)

class SDCZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "SmoothDoubleCubic", xZone: "double const", fShift: "double const", power: "unsigned int const"):
        _asepy.SDCZoneFunctor_swiginit(self, _asepy.new_SDCZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SDCZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_SDCZoneFunctor

# Register SDCZoneFunctor in _asepy:
_asepy.SDCZoneFunctor_swigregister(SDCZoneFunctor)

class LDSmoothDoubleCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_sigmaPlus: "long double const", i_sigmaMinus: "long double const", scaleNorm: "long double const"=1.0):
        _asepy.LDSmoothDoubleCubic_swiginit(self, _asepy.new_LDSmoothDoubleCubic(i_sigmaPlus, i_sigmaMinus, scaleNorm))

    def sigmaPlus(self) -> "long double":
        return _asepy.LDSmoothDoubleCubic_sigmaPlus(self)

    def sigmaMinus(self) -> "long double":
        return _asepy.LDSmoothDoubleCubic_sigmaMinus(self)

    def hasExtremum(self) -> "bool":
        return _asepy.LDSmoothDoubleCubic_hasExtremum(self)

    def isFlat(self) -> "bool":
        return _asepy.LDSmoothDoubleCubic_isFlat(self)

    def extremum(self) -> "std::pair< long double,long double >":
        return _asepy.LDSmoothDoubleCubic_extremum(self)

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDSmoothDoubleCubic___call__(self, x)

    def derivative(self, x: "long double const") -> "long double":
        return _asepy.LDSmoothDoubleCubic_derivative(self, x)

    def secondDerivative(self, x: "long double const") -> "long double":
        return _asepy.LDSmoothDoubleCubic_secondDerivative(self, x)

    def zoneContinuation(self, xZone: "long double const", x: "long double const") -> "long double":
        return _asepy.LDSmoothDoubleCubic_zoneContinuation(self, xZone, x)

    def inverse(self, y: "long double const", solutions: "long double [2]") -> "unsigned int":
        return _asepy.LDSmoothDoubleCubic_inverse(self, y, solutions)
    __swig_destroy__ = _asepy.delete_LDSmoothDoubleCubic

# Register LDSmoothDoubleCubic in _asepy:
_asepy.LDSmoothDoubleCubic_swigregister(LDSmoothDoubleCubic)

class LDSDCZoneFunctor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, curve: "LDSmoothDoubleCubic", xZone: "long double const", fShift: "long double const", power: "unsigned int const"):
        _asepy.LDSDCZoneFunctor_swiginit(self, _asepy.new_LDSDCZoneFunctor(curve, xZone, fShift, power))

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LDSDCZoneFunctor___call__(self, x)
    __swig_destroy__ = _asepy.delete_LDSDCZoneFunctor

# Register LDSDCZoneFunctor in _asepy:
_asepy.LDSDCZoneFunctor_swigregister(LDSDCZoneFunctor)

class OPATGaussian0(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.OPATGaussian0_isFullOPAT
    __swig_destroy__ = _asepy.delete_OPATGaussian0

    def sigmaPlus(self) -> "double":
        return _asepy.OPATGaussian0_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.OPATGaussian0_sigmaMinus(self)

    def setScale(self, s: "double const") -> "void":
        return _asepy.OPATGaussian0_setScale(self, s)

    def isUnimodal(self) -> "bool":
        return _asepy.OPATGaussian0_isUnimodal(self)

# Register OPATGaussian0 in _asepy:
_asepy.OPATGaussian0_swigregister(OPATGaussian0)

class OPATGaussian1(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.OPATGaussian1_isFullOPAT
    __swig_destroy__ = _asepy.delete_OPATGaussian1

    def sigmaPlus(self) -> "double":
        return _asepy.OPATGaussian1_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.OPATGaussian1_sigmaMinus(self)

    def setScale(self, s: "double const") -> "void":
        return _asepy.OPATGaussian1_setScale(self, s)

    def isUnimodal(self) -> "bool":
        return _asepy.OPATGaussian1_isUnimodal(self)

# Register OPATGaussian1 in _asepy:
_asepy.OPATGaussian1_swigregister(OPATGaussian1)

class OPATGaussian2(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.OPATGaussian2_isFullOPAT
    __swig_destroy__ = _asepy.delete_OPATGaussian2

    def sigmaPlus(self) -> "double":
        return _asepy.OPATGaussian2_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.OPATGaussian2_sigmaMinus(self)

    def setScale(self, s: "double const") -> "void":
        return _asepy.OPATGaussian2_setScale(self, s)

    def isUnimodal(self) -> "bool":
        return _asepy.OPATGaussian2_isUnimodal(self)

# Register OPATGaussian2 in _asepy:
_asepy.OPATGaussian2_swigregister(OPATGaussian2)

class DimidiatedGaussian(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.DimidiatedGaussian_isFullOPAT

    def __init__(self, *args):
        _asepy.DimidiatedGaussian_swiginit(self, _asepy.new_DimidiatedGaussian(*args))

    def clone(self) -> "ase::DimidiatedGaussian *":
        return _asepy.DimidiatedGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_DimidiatedGaussian

    def sigmaPlus(self) -> "double":
        return _asepy.DimidiatedGaussian_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.DimidiatedGaussian_sigmaMinus(self)

    def asymmetry(self) -> "double":
        return _asepy.DimidiatedGaussian_asymmetry(self)

    def isDensityContinuous(self) -> "bool":
        return _asepy.DimidiatedGaussian_isDensityContinuous(self)

    def setScale(self, s: "double") -> "void":
        return _asepy.DimidiatedGaussian_setScale(self, s)

    def classname(self) -> "std::string":
        return _asepy.DimidiatedGaussian_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DimidiatedGaussian *":
        return _asepy.DimidiatedGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

# Register DimidiatedGaussian in _asepy:
_asepy.DimidiatedGaussian_swigregister(DimidiatedGaussian)

def DimidiatedGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DimidiatedGaussian *":
    return _asepy.DimidiatedGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

class DistortedGaussian(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.DistortedGaussian_isFullOPAT

    def __init__(self, *args):
        _asepy.DistortedGaussian_swiginit(self, _asepy.new_DistortedGaussian(*args))

    def clone(self) -> "ase::DistortedGaussian *":
        return _asepy.DistortedGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_DistortedGaussian

    def sigmaPlus(self) -> "double":
        return _asepy.DistortedGaussian_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.DistortedGaussian_sigmaMinus(self)

    def isUnimodal(self) -> "bool":
        return _asepy.DistortedGaussian_isUnimodal(self)

    def setScale(self, s: "double") -> "void":
        return _asepy.DistortedGaussian_setScale(self, s)

    def classname(self) -> "std::string":
        return _asepy.DistortedGaussian_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DistortedGaussian *":
        return _asepy.DistortedGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

# Register DistortedGaussian in _asepy:
_asepy.DistortedGaussian_swigregister(DistortedGaussian)

def DistortedGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DistortedGaussian *":
    return _asepy.DistortedGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

class RailwayGaussian(OPATGaussian1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.RailwayGaussian_swiginit(self, _asepy.new_RailwayGaussian(*args))

    def clone(self) -> "ase::RailwayGaussian *":
        return _asepy.RailwayGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_RailwayGaussian

    def hleft(self) -> "double":
        return _asepy.RailwayGaussian_hleft(self)

    def hright(self) -> "double":
        return _asepy.RailwayGaussian_hright(self)

    def classname(self) -> "std::string":
        return _asepy.RailwayGaussian_classname(self)

    @staticmethod
    def transitionRegionChoice(sigmaPlus: "double", sigmaMinus: "double") -> "std::pair< double,double >":
        return _asepy.RailwayGaussian_transitionRegionChoice(sigmaPlus, sigmaMinus)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::RailwayGaussian *":
        return _asepy.RailwayGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::RailwayGaussian *":
        return _asepy.RailwayGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register RailwayGaussian in _asepy:
_asepy.RailwayGaussian_swigregister(RailwayGaussian)

def RailwayGaussian_transitionRegionChoice(sigmaPlus: "double", sigmaMinus: "double") -> "std::pair< double,double >":
    return _asepy.RailwayGaussian_transitionRegionChoice(sigmaPlus, sigmaMinus)

def RailwayGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::RailwayGaussian *":
    return _asepy.RailwayGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

def RailwayGaussian_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::RailwayGaussian *":
    return _asepy.RailwayGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class DoubleCubicGaussian(OPATGaussian2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.DoubleCubicGaussian_swiginit(self, _asepy.new_DoubleCubicGaussian(*args))

    def clone(self) -> "ase::DoubleCubicGaussian *":
        return _asepy.DoubleCubicGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_DoubleCubicGaussian

    def classname(self) -> "std::string":
        return _asepy.DoubleCubicGaussian_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DoubleCubicGaussian *":
        return _asepy.DoubleCubicGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::DoubleCubicGaussian *":
        return _asepy.DoubleCubicGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register DoubleCubicGaussian in _asepy:
_asepy.DoubleCubicGaussian_swigregister(DoubleCubicGaussian)

def DoubleCubicGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::DoubleCubicGaussian *":
    return _asepy.DoubleCubicGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

def DoubleCubicGaussian_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::DoubleCubicGaussian *":
    return _asepy.DoubleCubicGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SkewNormal(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.SkewNormal_isFullOPAT

    def __init__(self, *args):
        _asepy.SkewNormal_swiginit(self, _asepy.new_SkewNormal(*args))

    def clone(self) -> "ase::SkewNormal *":
        return _asepy.SkewNormal_clone(self)
    __swig_destroy__ = _asepy.delete_SkewNormal

    def shapeParameter(self) -> "double":
        return _asepy.SkewNormal_shapeParameter(self)

    def classname(self) -> "std::string":
        return _asepy.SkewNormal_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SkewNormal *":
        return _asepy.SkewNormal_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SkewNormal *":
        return _asepy.SkewNormal_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SkewNormal in _asepy:
_asepy.SkewNormal_swigregister(SkewNormal)

def SkewNormal_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SkewNormal *":
    return _asepy.SkewNormal_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SkewNormal_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SkewNormal *":
    return _asepy.SkewNormal_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class QVWGaussian(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.QVWGaussian_isFullOPAT

    def __init__(self, *args):
        _asepy.QVWGaussian_swiginit(self, _asepy.new_QVWGaussian(*args))

    def clone(self) -> "ase::QVWGaussian *":
        return _asepy.QVWGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_QVWGaussian

    def asymmetryParameter(self) -> "double":
        return _asepy.QVWGaussian_asymmetryParameter(self)

    def locationParameter(self) -> "double":
        return _asepy.QVWGaussian_locationParameter(self)

    def scaleParameter(self) -> "double":
        return _asepy.QVWGaussian_scaleParameter(self)

    def classname(self) -> "std::string":
        return _asepy.QVWGaussian_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::QVWGaussian *":
        return _asepy.QVWGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::QVWGaussian *":
        return _asepy.QVWGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register QVWGaussian in _asepy:
_asepy.QVWGaussian_swigregister(QVWGaussian)

def QVWGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::QVWGaussian *":
    return _asepy.QVWGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus)

def QVWGaussian_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::QVWGaussian *":
    return _asepy.QVWGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class GammaDistribution(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.GammaDistribution_isFullOPAT

    def __init__(self, *args):
        _asepy.GammaDistribution_swiginit(self, _asepy.new_GammaDistribution(*args))

    def clone(self) -> "ase::GammaDistribution *":
        return _asepy.GammaDistribution_clone(self)
    __swig_destroy__ = _asepy.delete_GammaDistribution

    def shapeParameter(self) -> "double":
        return _asepy.GammaDistribution_shapeParameter(self)

    def classname(self) -> "std::string":
        return _asepy.GammaDistribution_classname(self)

# Register GammaDistribution in _asepy:
_asepy.GammaDistribution_swigregister(GammaDistribution)

class LogNormal(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.LogNormal_isFullOPAT

    def __init__(self, *args):
        _asepy.LogNormal_swiginit(self, _asepy.new_LogNormal(*args))

    def clone(self) -> "ase::LogNormal *":
        return _asepy.LogNormal_clone(self)
    __swig_destroy__ = _asepy.delete_LogNormal

    def skewness(self) -> "double":
        return _asepy.LogNormal_skewness(self)

    def kurtosis(self) -> "double":
        return _asepy.LogNormal_kurtosis(self)

    def isGaussian(self) -> "bool":
        return _asepy.LogNormal_isGaussian(self)

    def entropy(self) -> "double":
        return _asepy.LogNormal_entropy(self)

    def classname(self) -> "std::string":
        return _asepy.LogNormal_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::LogNormal *":
        return _asepy.LogNormal_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::LogNormal *":
        return _asepy.LogNormal_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register LogNormal in _asepy:
_asepy.LogNormal_swigregister(LogNormal)

def LogNormal_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::LogNormal *":
    return _asepy.LogNormal_fromQuantiles(median, sigmaPlus, sigmaMinus)

def LogNormal_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::LogNormal *":
    return _asepy.LogNormal_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class JohnsonSu(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.JohnsonSu_isFullOPAT

    def __init__(self, *args):
        _asepy.JohnsonSu_swiginit(self, _asepy.new_JohnsonSu(*args))

    def clone(self) -> "ase::JohnsonSu *":
        return _asepy.JohnsonSu_clone(self)
    __swig_destroy__ = _asepy.delete_JohnsonSu

    def skewness(self) -> "double":
        return _asepy.JohnsonSu_skewness(self)

    def kurtosis(self) -> "double":
        return _asepy.JohnsonSu_kurtosis(self)

    def isValid(self) -> "bool":
        return _asepy.JohnsonSu_isValid(self)

    def getDelta(self) -> "double":
        return _asepy.JohnsonSu_getDelta(self)

    def getLambda(self) -> "double":
        return _asepy.JohnsonSu_getLambda(self)

    def getGamma(self) -> "double":
        return _asepy.JohnsonSu_getGamma(self)

    def getXi(self) -> "double":
        return _asepy.JohnsonSu_getXi(self)

    def entropy(self) -> "double":
        return _asepy.JohnsonSu_entropy(self)

    def classname(self) -> "std::string":
        return _asepy.JohnsonSu_classname(self)

# Register JohnsonSu in _asepy:
_asepy.JohnsonSu_swigregister(JohnsonSu)

class JohnsonSb(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.JohnsonSb_isFullOPAT

    def __init__(self, *args):
        _asepy.JohnsonSb_swiginit(self, _asepy.new_JohnsonSb(*args))

    def clone(self) -> "ase::JohnsonSb *":
        return _asepy.JohnsonSb_clone(self)
    __swig_destroy__ = _asepy.delete_JohnsonSb

    def skewness(self) -> "double":
        return _asepy.JohnsonSb_skewness(self)

    def kurtosis(self) -> "double":
        return _asepy.JohnsonSb_kurtosis(self)

    def isValid(self) -> "bool":
        return _asepy.JohnsonSb_isValid(self)

    def isUnimodal(self) -> "bool":
        return _asepy.JohnsonSb_isUnimodal(self)

    def getDelta(self) -> "double":
        return _asepy.JohnsonSb_getDelta(self)

    def getLambda(self) -> "double":
        return _asepy.JohnsonSb_getLambda(self)

    def getGamma(self) -> "double":
        return _asepy.JohnsonSb_getGamma(self)

    def getXi(self) -> "double":
        return _asepy.JohnsonSb_getXi(self)

    def entropy(self) -> "double":
        return _asepy.JohnsonSb_entropy(self)

    def classname(self) -> "std::string":
        return _asepy.JohnsonSb_classname(self)

    @staticmethod
    def fitParameters(skewness: "double", kurtosis: "double", gamma: "double *", delta: "double *", _lambda: "double *", xi: "double *") -> "bool":
        return _asepy.JohnsonSb_fitParameters(skewness, kurtosis, gamma, delta, _lambda, xi)

# Register JohnsonSb in _asepy:
_asepy.JohnsonSb_swigregister(JohnsonSb)

def JohnsonSb_fitParameters(skewness: "double", kurtosis: "double", gamma: "double *", delta: "double *", _lambda: "double *", xi: "double *") -> "bool":
    return _asepy.JohnsonSb_fitParameters(skewness, kurtosis, gamma, delta, _lambda, xi)

class JohnsonSystem(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.JohnsonSystem_isFullOPAT
    GAUSSIAN = _asepy.JohnsonSystem_GAUSSIAN
    LOGNORMAL = _asepy.JohnsonSystem_LOGNORMAL
    SU = _asepy.JohnsonSystem_SU
    SB = _asepy.JohnsonSystem_SB
    INVALID = _asepy.JohnsonSystem_INVALID

    def __init__(self, *args):
        _asepy.JohnsonSystem_swiginit(self, _asepy.new_JohnsonSystem(*args))
    __swig_destroy__ = _asepy.delete_JohnsonSystem

    def clone(self) -> "ase::JohnsonSystem *":
        return _asepy.JohnsonSystem_clone(self)

    def skewness(self) -> "double":
        return _asepy.JohnsonSystem_skewness(self)

    def kurtosis(self) -> "double":
        return _asepy.JohnsonSystem_kurtosis(self)

    def curveType(self) -> "ase::JohnsonSystem::CurveType":
        return _asepy.JohnsonSystem_curveType(self)

    def entropy(self) -> "double":
        return _asepy.JohnsonSystem_entropy(self)

    def isUnimodal(self) -> "bool":
        return _asepy.JohnsonSystem_isUnimodal(self)

    def isValid(self) -> "bool":
        return _asepy.JohnsonSystem_isValid(self)

    def classname(self) -> "std::string":
        return _asepy.JohnsonSystem_classname(self)

    def subclass(self) -> "std::string":
        return _asepy.JohnsonSystem_subclass(self)

    @staticmethod
    def select(skewness: "double", kurtosis: "double") -> "ase::JohnsonSystem::CurveType":
        return _asepy.JohnsonSystem_select(skewness, kurtosis)

    @staticmethod
    def slowMaxEntKurtosis(skewness: "double") -> "double":
        return _asepy.JohnsonSystem_slowMaxEntKurtosis(skewness)

    @staticmethod
    def approxMaxEntKurtosis(skewness: "double") -> "double":
        return _asepy.JohnsonSystem_approxMaxEntKurtosis(skewness)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::JohnsonSystem *":
        return _asepy.JohnsonSystem_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::JohnsonSystem *":
        return _asepy.JohnsonSystem_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register JohnsonSystem in _asepy:
_asepy.JohnsonSystem_swigregister(JohnsonSystem)

def JohnsonSystem_select(skewness: "double", kurtosis: "double") -> "ase::JohnsonSystem::CurveType":
    return _asepy.JohnsonSystem_select(skewness, kurtosis)

def JohnsonSystem_slowMaxEntKurtosis(skewness: "double") -> "double":
    return _asepy.JohnsonSystem_slowMaxEntKurtosis(skewness)

def JohnsonSystem_approxMaxEntKurtosis(skewness: "double") -> "double":
    return _asepy.JohnsonSystem_approxMaxEntKurtosis(skewness)

def JohnsonSystem_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::JohnsonSystem *":
    return _asepy.JohnsonSystem_fromQuantiles(median, sigmaPlus, sigmaMinus)

def JohnsonSystem_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::JohnsonSystem *":
    return _asepy.JohnsonSystem_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class EdgeworthExpansion3(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.EdgeworthExpansion3_isFullOPAT

    def __init__(self, *args):
        _asepy.EdgeworthExpansion3_swiginit(self, _asepy.new_EdgeworthExpansion3(*args))

    def clone(self) -> "ase::EdgeworthExpansion3 *":
        return _asepy.EdgeworthExpansion3_clone(self)
    __swig_destroy__ = _asepy.delete_EdgeworthExpansion3

    def isNonNegative(self) -> "bool":
        return _asepy.EdgeworthExpansion3_isNonNegative(self)

    def skewness(self) -> "double":
        return _asepy.EdgeworthExpansion3_skewness(self)

    def safeSigmaRange(self) -> "double":
        return _asepy.EdgeworthExpansion3_safeSigmaRange(self)

    def classname(self) -> "std::string":
        return _asepy.EdgeworthExpansion3_classname(self)

    @staticmethod
    def classSafeSigmaRange() -> "double":
        return _asepy.EdgeworthExpansion3_classSafeSigmaRange()

    @staticmethod
    def setClassSafeSigmaRange(range: "double") -> "void":
        return _asepy.EdgeworthExpansion3_setClassSafeSigmaRange(range)

    @staticmethod
    def restoreDefaultSafeSigmaRange() -> "void":
        return _asepy.EdgeworthExpansion3_restoreDefaultSafeSigmaRange()

    @staticmethod
    def largestSkewAllowed(range: "double") -> "double":
        return _asepy.EdgeworthExpansion3_largestSkewAllowed(range)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::EdgeworthExpansion3 *":
        return _asepy.EdgeworthExpansion3_fromQuantiles(median, sigmaPlus, sigmaMinus)

# Register EdgeworthExpansion3 in _asepy:
_asepy.EdgeworthExpansion3_swigregister(EdgeworthExpansion3)

def EdgeworthExpansion3_classSafeSigmaRange() -> "double":
    return _asepy.EdgeworthExpansion3_classSafeSigmaRange()

def EdgeworthExpansion3_setClassSafeSigmaRange(range: "double") -> "void":
    return _asepy.EdgeworthExpansion3_setClassSafeSigmaRange(range)

def EdgeworthExpansion3_restoreDefaultSafeSigmaRange() -> "void":
    return _asepy.EdgeworthExpansion3_restoreDefaultSafeSigmaRange()

def EdgeworthExpansion3_largestSkewAllowed(range: "double") -> "double":
    return _asepy.EdgeworthExpansion3_largestSkewAllowed(range)

def EdgeworthExpansion3_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::EdgeworthExpansion3 *":
    return _asepy.EdgeworthExpansion3_fromQuantiles(median, sigmaPlus, sigmaMinus)

class FechnerDistribution(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.FechnerDistribution_isFullOPAT

    def __init__(self, *args):
        _asepy.FechnerDistribution_swiginit(self, _asepy.new_FechnerDistribution(*args))

    def clone(self) -> "ase::FechnerDistribution *":
        return _asepy.FechnerDistribution_clone(self)
    __swig_destroy__ = _asepy.delete_FechnerDistribution

    def sigmaPlus(self) -> "double":
        return _asepy.FechnerDistribution_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.FechnerDistribution_sigmaMinus(self)

    def classname(self) -> "std::string":
        return _asepy.FechnerDistribution_classname(self)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::FechnerDistribution *":
        return _asepy.FechnerDistribution_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::FechnerDistribution *":
        return _asepy.FechnerDistribution_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register FechnerDistribution in _asepy:
_asepy.FechnerDistribution_swigregister(FechnerDistribution)

def FechnerDistribution_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::FechnerDistribution *":
    return _asepy.FechnerDistribution_fromQuantiles(median, sigmaPlus, sigmaMinus)

def FechnerDistribution_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::FechnerDistribution *":
    return _asepy.FechnerDistribution_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class EmpiricalDistribution(AbsDistributionModel1D):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.EmpiricalDistribution_isFullOPAT

    def __init__(self, sample: "DoubleVector", isAlreadySorted: "bool"=False):
        _asepy.EmpiricalDistribution_swiginit(self, _asepy.new_EmpiricalDistribution(sample, isAlreadySorted))

    def clone(self) -> "ase::EmpiricalDistribution *":
        return _asepy.EmpiricalDistribution_clone(self)
    __swig_destroy__ = _asepy.delete_EmpiricalDistribution

    def density(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_density(self, x)

    def densityDerivative(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_densityDerivative(self, x)

    def mode(self) -> "double":
        return _asepy.EmpiricalDistribution_mode(self)

    def descentDelta(self, isToTheRight: "bool", deltaLnL: "double"=0.5) -> "double":
        return _asepy.EmpiricalDistribution_descentDelta(self, isToTheRight, deltaLnL)

    def cdf(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_cdf(self, x)

    def exceedance(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_exceedance(self, x)

    def quantile(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_quantile(self, x)

    def invExceedance(self, x: "double") -> "double":
        return _asepy.EmpiricalDistribution_invExceedance(self, x)

    def cumulant(self, n: "unsigned int") -> "double":
        return _asepy.EmpiricalDistribution_cumulant(self, n)

    def classname(self) -> "std::string":
        return _asepy.EmpiricalDistribution_classname(self)

    def random(self, gen: "AbsRNG") -> "double":
        return _asepy.EmpiricalDistribution_random(self, gen)

    def sampleSize(self) -> "unsigned long":
        return _asepy.EmpiricalDistribution_sampleSize(self)

    def coordinate(self, i: "unsigned long const") -> "double":
        return _asepy.EmpiricalDistribution_coordinate(self, i)

    def minCoordinate(self) -> "double":
        return _asepy.EmpiricalDistribution_minCoordinate(self)

    def maxCoordinate(self) -> "double":
        return _asepy.EmpiricalDistribution_maxCoordinate(self)

# Register EmpiricalDistribution in _asepy:
_asepy.EmpiricalDistribution_swigregister(EmpiricalDistribution)

class UniformDistribution(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.UniformDistribution_isFullOPAT

    def __init__(self, *args):
        _asepy.UniformDistribution_swiginit(self, _asepy.new_UniformDistribution(*args))

    def clone(self) -> "ase::UniformDistribution *":
        return _asepy.UniformDistribution_clone(self)
    __swig_destroy__ = _asepy.delete_UniformDistribution

    def isUnimodal(self) -> "bool":
        return _asepy.UniformDistribution_isUnimodal(self)

    def classname(self) -> "std::string":
        return _asepy.UniformDistribution_classname(self)

# Register UniformDistribution in _asepy:
_asepy.UniformDistribution_swigregister(UniformDistribution)

class ExponentialDistribution(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.ExponentialDistribution_isFullOPAT

    def __init__(self, *args):
        _asepy.ExponentialDistribution_swiginit(self, _asepy.new_ExponentialDistribution(*args))

    def clone(self) -> "ase::ExponentialDistribution *":
        return _asepy.ExponentialDistribution_clone(self)
    __swig_destroy__ = _asepy.delete_ExponentialDistribution

    def classname(self) -> "std::string":
        return _asepy.ExponentialDistribution_classname(self)

# Register ExponentialDistribution in _asepy:
_asepy.ExponentialDistribution_swigregister(ExponentialDistribution)


def inverseGaussCdf(cdf: "double") -> "double":
    return _asepy.inverseGaussCdf(cdf)

def owensT(h: "double", alpha: "double") -> "double":
    return _asepy.owensT(h, alpha)

def Gamma(x: "double") -> "double":
    return _asepy.Gamma(x)

def incompleteGamma(a: "double", x: "double") -> "double":
    return _asepy.incompleteGamma(a, x)

def inverseIncompleteGamma(a: "double", x: "double") -> "double":
    return _asepy.inverseIncompleteGamma(a, x)

def incompleteGammaC(a: "double", x: "double") -> "double":
    return _asepy.incompleteGammaC(a, x)

def inverseIncompleteGammaC(a: "double", x: "double") -> "double":
    return _asepy.inverseIncompleteGammaC(a, x)
class LegendreDistro1D(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.LegendreDistro1D_isFullOPAT

    def __init__(self, location: "double", scale: "double", coeffs: "DoubleVector", ensurePositivity: "bool"=True):
        _asepy.LegendreDistro1D_swiginit(self, _asepy.new_LegendreDistro1D(location, scale, coeffs, ensurePositivity))

    def clone(self) -> "ase::LegendreDistro1D *":
        return _asepy.LegendreDistro1D_clone(self)
    __swig_destroy__ = _asepy.delete_LegendreDistro1D

    def nCoeffs(self) -> "unsigned int":
        return _asepy.LegendreDistro1D_nCoeffs(self)

    def getCoeff(self, i: "unsigned int const") -> "double":
        return _asepy.LegendreDistro1D_getCoeff(self, i)

    def isNonNegative(self) -> "bool":
        return _asepy.LegendreDistro1D_isNonNegative(self)

    def isUnimodal(self) -> "bool":
        return _asepy.LegendreDistro1D_isUnimodal(self)

    def classname(self) -> "std::string":
        return _asepy.LegendreDistro1D_classname(self)

# Register LegendreDistro1D in _asepy:
_asepy.LegendreDistro1D_swigregister(LegendreDistro1D)

class AbsLogLikelihoodCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_AbsLogLikelihoodCurve

    def clone(self) -> "ase::AbsLogLikelihoodCurve *":
        return _asepy.AbsLogLikelihoodCurve_clone(self)

    def parMin(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_parMin(self)

    def parMax(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_parMax(self)

    def location(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_location(self)

    def stepSize(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_stepSize(self)

    def maximum(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_maximum(self)

    def argmax(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_argmax(self)

    def __call__(self, parameter: "double") -> "double":
        return _asepy.AbsLogLikelihoodCurve___call__(self, parameter)

    def derivative(self, parameter: "double") -> "double":
        return _asepy.AbsLogLikelihoodCurve_derivative(self, parameter)

    def secondDerivative(self, param: "double", step: "double"=0.0) -> "double":
        return _asepy.AbsLogLikelihoodCurve_secondDerivative(self, param, step)

    def classname(self) -> "std::string":
        return _asepy.AbsLogLikelihoodCurve_classname(self)

    def __imul__(self, c: "double") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.AbsLogLikelihoodCurve___imul__(self, c)

    def __itruediv__(self, *args):
        return _asepy.AbsLogLikelihoodCurve___idiv__(self, *args)
    __idiv__ = __itruediv__



    def sigmaPlus(self, deltaLogLikelihood: "double"=0.5, stepFactor: "double"=1.1) -> "double":
        return _asepy.AbsLogLikelihoodCurve_sigmaPlus(self, deltaLogLikelihood, stepFactor)

    def sigmaMinus(self, deltaLogLikelihood: "double"=0.5, stepFactor: "double"=1.1) -> "double":
        return _asepy.AbsLogLikelihoodCurve_sigmaMinus(self, deltaLogLikelihood, stepFactor)

    def findLocalMaximum(self, startingPoint: "double", searchToTheRight: "bool", maxSteps: "unsigned int", stepFactor: "double"=1.1) -> "std::pair< double,double >":
        return _asepy.AbsLogLikelihoodCurve_findLocalMaximum(self, startingPoint, searchToTheRight, maxSteps, stepFactor)

    def posteriorMean(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.AbsLogLikelihoodCurve_posteriorVariance(self)

    def __add__(self, r: "AbsLogLikelihoodCurve") -> "ase::LikelihoodCurveCopy":
        return _asepy.AbsLogLikelihoodCurve___add__(self, r)

    def __sub__(self, r: "AbsLogLikelihoodCurve") -> "ase::LikelihoodCurveCopy":
        return _asepy.AbsLogLikelihoodCurve___sub__(self, r)

    def __mul__(self, r: "double const &") -> "ase::LikelihoodCurveCopy":
        return _asepy.AbsLogLikelihoodCurve___mul__(self, r)

    def __rmul__(self, r: "double const &") -> "ase::LikelihoodCurveCopy":
        return _asepy.AbsLogLikelihoodCurve___rmul__(self, r)

    def __truediv__(self, r: "double const &") -> "ase::LikelihoodCurveCopy":
        return _asepy.AbsLogLikelihoodCurve___truediv__(self, r)

# Register AbsLogLikelihoodCurve in _asepy:
_asepy.AbsLogLikelihoodCurve_swigregister(AbsLogLikelihoodCurve)

class LogLikelihoodDerivative(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLogLikelihoodCurve"):
        _asepy.LogLikelihoodDerivative_swiginit(self, _asepy.new_LogLikelihoodDerivative(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.LogLikelihoodDerivative___call__(self, x)
    __swig_destroy__ = _asepy.delete_LogLikelihoodDerivative

# Register LogLikelihoodDerivative in _asepy:
_asepy.LogLikelihoodDerivative_swigregister(LogLikelihoodDerivative)

class LogLikelihoodSecondDerivative(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "AbsLogLikelihoodCurve", step: "double const"):
        _asepy.LogLikelihoodSecondDerivative_swiginit(self, _asepy.new_LogLikelihoodSecondDerivative(fcn, step))

    def __call__(self, x: "double const") -> "double":
        return _asepy.LogLikelihoodSecondDerivative___call__(self, x)
    __swig_destroy__ = _asepy.delete_LogLikelihoodSecondDerivative

# Register LogLikelihoodSecondDerivative in _asepy:
_asepy.LogLikelihoodSecondDerivative_swigregister(LogLikelihoodSecondDerivative)

class LikelihoodCurveCopy(AbsLogLikelihoodCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.LikelihoodCurveCopy_swiginit(self, _asepy.new_LikelihoodCurveCopy(*args))

    def clone(self) -> "ase::LikelihoodCurveCopy *":
        return _asepy.LikelihoodCurveCopy_clone(self)
    __swig_destroy__ = _asepy.delete_LikelihoodCurveCopy

    def theCopy(self) -> "ase::AbsLogLikelihoodCurve const &":
        return _asepy.LikelihoodCurveCopy_theCopy(self)

    def parMin(self) -> "double":
        return _asepy.LikelihoodCurveCopy_parMin(self)

    def parMax(self) -> "double":
        return _asepy.LikelihoodCurveCopy_parMax(self)

    def location(self) -> "double":
        return _asepy.LikelihoodCurveCopy_location(self)

    def stepSize(self) -> "double":
        return _asepy.LikelihoodCurveCopy_stepSize(self)

    def maximum(self) -> "double":
        return _asepy.LikelihoodCurveCopy_maximum(self)

    def argmax(self) -> "double":
        return _asepy.LikelihoodCurveCopy_argmax(self)

    def __call__(self, p: "double const") -> "double":
        return _asepy.LikelihoodCurveCopy___call__(self, p)

    def derivative(self, p: "double const") -> "double":
        return _asepy.LikelihoodCurveCopy_derivative(self, p)

    def secondDerivative(self, p: "double const", step: "double const"=0.0) -> "double":
        return _asepy.LikelihoodCurveCopy_secondDerivative(self, p, step)

    def classname(self) -> "std::string":
        return _asepy.LikelihoodCurveCopy_classname(self)

    def __imul__(self, c: "double const") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.LikelihoodCurveCopy___imul__(self, c)

    def __itruediv__(self, *args):
        return _asepy.LikelihoodCurveCopy___idiv__(self, *args)
    __idiv__ = __itruediv__



    def sigmaPlus(self, deltaLogLikelihood: "double const"=0.5, stepFactor: "double const"=1.1) -> "double":
        return _asepy.LikelihoodCurveCopy_sigmaPlus(self, deltaLogLikelihood, stepFactor)

    def sigmaMinus(self, deltaLogLikelihood: "double const"=0.5, stepFactor: "double const"=1.1) -> "double":
        return _asepy.LikelihoodCurveCopy_sigmaMinus(self, deltaLogLikelihood, stepFactor)

    def findLocalMaximum(self, startingPoint: "double const", searchToTheRight: "bool const", maxSteps: "unsigned int const", stepFactor: "double const"=1.1) -> "std::pair< double,double >":
        return _asepy.LikelihoodCurveCopy_findLocalMaximum(self, startingPoint, searchToTheRight, maxSteps, stepFactor)

    def posteriorMean(self) -> "double":
        return _asepy.LikelihoodCurveCopy_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.LikelihoodCurveCopy_posteriorVariance(self)

# Register LikelihoodCurveCopy in _asepy:
_asepy.LikelihoodCurveCopy_swigregister(LikelihoodCurveCopy)

class CubicHermiteInterpolatorEG(AbsLogLikelihoodCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clone(self) -> "ase::CubicHermiteInterpolatorEG *":
        return _asepy.CubicHermiteInterpolatorEG_clone(self)
    __swig_destroy__ = _asepy.delete_CubicHermiteInterpolatorEG

    def parMin(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_parMin(self)

    def parMax(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_parMax(self)

    def nPoints(self) -> "unsigned int":
        return _asepy.CubicHermiteInterpolatorEG_nPoints(self)

    def stepSize(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_stepSize(self)

    def getValues(self) -> "std::vector< double,std::allocator< double > > const &":
        return _asepy.CubicHermiteInterpolatorEG_getValues(self)

    def getDerivatives(self) -> "std::vector< double,std::allocator< double > > const &":
        return _asepy.CubicHermiteInterpolatorEG_getDerivatives(self)

    def location(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_location(self)

    def maximum(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_maximum(self)

    def argmax(self) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_argmax(self)

    def __call__(self, parameter: "double") -> "double":
        return _asepy.CubicHermiteInterpolatorEG___call__(self, parameter)

    def derivative(self, parameter: "double") -> "double":
        return _asepy.CubicHermiteInterpolatorEG_derivative(self, parameter)

    def secondDerivative(self, parameter: "double", step: "double"=0.0) -> "double":
        return _asepy.CubicHermiteInterpolatorEG_secondDerivative(self, parameter, step)

    def classname(self) -> "std::string":
        return _asepy.CubicHermiteInterpolatorEG_classname(self)

    def __imul__(self, c: "double") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.CubicHermiteInterpolatorEG___imul__(self, c)

    def __init__(self, *args):
        _asepy.CubicHermiteInterpolatorEG_swiginit(self, _asepy.new_CubicHermiteInterpolatorEG(*args))

# Register CubicHermiteInterpolatorEG in _asepy:
_asepy.CubicHermiteInterpolatorEG_swigregister(CubicHermiteInterpolatorEG)

class InterpolatedDensity1D(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.InterpolatedDensity1D_isFullOPAT

    def clone(self) -> "ase::InterpolatedDensity1D *":
        return _asepy.InterpolatedDensity1D_clone(self)
    __swig_destroy__ = _asepy.delete_InterpolatedDensity1D

    def isUnimodal(self) -> "bool":
        return _asepy.InterpolatedDensity1D_isUnimodal(self)

    def classname(self) -> "std::string":
        return _asepy.InterpolatedDensity1D_classname(self)

    def entropy(self) -> "double":
        return _asepy.InterpolatedDensity1D_entropy(self)

    def nCoords(self) -> "unsigned int":
        return _asepy.InterpolatedDensity1D_nCoords(self)

    def __init__(self, *args):
        _asepy.InterpolatedDensity1D_swiginit(self, _asepy.new_InterpolatedDensity1D(*args))

# Register InterpolatedDensity1D in _asepy:
_asepy.InterpolatedDensity1D_swigregister(InterpolatedDensity1D)

class TransitionCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_x0: "double const", i_h: "double const", valueAtX0: "double const", derivativeAtX0: "double const", secondDerivativeAtX0: "double const"):
        _asepy.TransitionCubic_swiginit(self, _asepy.new_TransitionCubic(i_x0, i_h, valueAtX0, derivativeAtX0, secondDerivativeAtX0))

    def x0(self) -> "double":
        return _asepy.TransitionCubic_x0(self)

    def h(self) -> "double":
        return _asepy.TransitionCubic_h(self)

    def __call__(self, x_in: "double const") -> "double":
        return _asepy.TransitionCubic___call__(self, x_in)

    def derivative(self, x_in: "double const") -> "double":
        return _asepy.TransitionCubic_derivative(self, x_in)

    def secondDerivative(self, x_in: "double const") -> "double":
        return _asepy.TransitionCubic_secondDerivative(self, x_in)

    def hasExtremum(self) -> "bool":
        return _asepy.TransitionCubic_hasExtremum(self)

    def extremum(self) -> "std::pair< double,double >":
        return _asepy.TransitionCubic_extremum(self)
    __swig_destroy__ = _asepy.delete_TransitionCubic

# Register TransitionCubic in _asepy:
_asepy.TransitionCubic_swigregister(TransitionCubic)

class DoubleCubicInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, y0: "double", sigmaPlus: "double", yPlus: "double", sigmaMinus: "double", yMinus: "double"):
        _asepy.DoubleCubicInner_swiginit(self, _asepy.new_DoubleCubicInner(y0, sigmaPlus, yPlus, sigmaMinus, yMinus))

    def __call__(self, x: "double") -> "double":
        return _asepy.DoubleCubicInner___call__(self, x)

    def derivative(self, x: "double") -> "double":
        return _asepy.DoubleCubicInner_derivative(self, x)

    def secondDerivative(self, x: "double") -> "double":
        return _asepy.DoubleCubicInner_secondDerivative(self, x)
    __swig_destroy__ = _asepy.delete_DoubleCubicInner

# Register DoubleCubicInner in _asepy:
_asepy.DoubleCubicInner_swigregister(DoubleCubicInner)

class Poly1D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.Poly1D_swiginit(self, _asepy.new_Poly1D(*args))

    def reserve(self, degree: "unsigned int const") -> "void":
        return _asepy.Poly1D_reserve(self, degree)

    def truncate(self, maxDegree: "unsigned int const") -> "void":
        return _asepy.Poly1D_truncate(self, maxDegree)

    def truncateLeadingZeros(self) -> "void":
        return _asepy.Poly1D_truncateLeadingZeros(self)

    def setCoefficient(self, degree: "unsigned int", value: "long double") -> "void":
        return _asepy.Poly1D_setCoefficient(self, degree, value)

    def deg(self) -> "unsigned int":
        return _asepy.Poly1D_deg(self)

    def allCoefficients(self) -> "std::vector< long double,std::allocator< long double > > const &":
        return _asepy.Poly1D_allCoefficients(self)

    def leadingCoefficient(self) -> "long double":
        return _asepy.Poly1D_leadingCoefficient(self)

    def nRoots(self, a: "long double", b: "long double") -> "unsigned int":
        return _asepy.Poly1D_nRoots(self, a, b)

    def findRoots(self, a: "long double", b: "long double", roots: "long double *") -> "unsigned int":
        return _asepy.Poly1D_findRoots(self, a, b, roots)

    def __call__(self, x: "long double") -> "long double":
        return _asepy.Poly1D___call__(self, x)

    def valueAndDerivative(self, x: "long double", value: "long double *", derivative: "long double *") -> "void":
        return _asepy.Poly1D_valueAndDerivative(self, x, value, derivative)

    def isClose(self, r: "Poly1D", eps: "long double") -> "bool":
        return _asepy.Poly1D_isClose(self, r, eps)

    def isNull(self) -> "bool":
        return _asepy.Poly1D_isNull(self)

    def derivative(self) -> "ase::Poly1D":
        return _asepy.Poly1D_derivative(self)

    def integral(self, c: "long double") -> "ase::Poly1D":
        return _asepy.Poly1D_integral(self, c)

    def __pos__(self) -> "ase::Poly1D":
        return _asepy.Poly1D___pos__(self)

    def __neg__(self) -> "ase::Poly1D":
        return _asepy.Poly1D___neg__(self)

    def __mul__(self, arg2: "Poly1D") -> "ase::Poly1D":
        return _asepy.Poly1D___mul__(self, arg2)

    def __add__(self, arg2: "Poly1D") -> "ase::Poly1D":
        return _asepy.Poly1D___add__(self, arg2)

    def __sub__(self, arg2: "Poly1D") -> "ase::Poly1D":
        return _asepy.Poly1D___sub__(self, arg2)

    def __imul__(self, arg2: "Poly1D") -> "ase::Poly1D &":
        return _asepy.Poly1D___imul__(self, arg2)

    def __iadd__(self, arg2: "Poly1D") -> "ase::Poly1D &":
        return _asepy.Poly1D___iadd__(self, arg2)

    def __isub__(self, arg2: "Poly1D") -> "ase::Poly1D &":
        return _asepy.Poly1D___isub__(self, arg2)

    def __truediv__(self, *args):
        return _asepy.Poly1D___truediv__(self, *args)
    __div__ = __truediv__



    def __mod__(self, arg2: "Poly1D") -> "ase::Poly1D":
        return _asepy.Poly1D___mod__(self, arg2)

    def __eq__(self, r: "Poly1D") -> "bool":
        return _asepy.Poly1D___eq__(self, r)

    def __ne__(self, r: "Poly1D") -> "bool":
        return _asepy.Poly1D___ne__(self, r)

    @staticmethod
    def monicDeg0() -> "ase::Poly1D":
        return _asepy.Poly1D_monicDeg0()

    @staticmethod
    def monicDeg1(b: "long double") -> "ase::Poly1D":
        return _asepy.Poly1D_monicDeg1(b)

    @staticmethod
    def monicDeg2(b: "long double", c: "long double") -> "ase::Poly1D":
        return _asepy.Poly1D_monicDeg2(b, c)
    __swig_destroy__ = _asepy.delete_Poly1D

# Register Poly1D in _asepy:
_asepy.Poly1D_swigregister(Poly1D)

def Poly1D_monicDeg0() -> "ase::Poly1D":
    return _asepy.Poly1D_monicDeg0()

def Poly1D_monicDeg1(b: "long double") -> "ase::Poly1D":
    return _asepy.Poly1D_monicDeg1(b)

def Poly1D_monicDeg2(b: "long double", c: "long double") -> "ase::Poly1D":
    return _asepy.Poly1D_monicDeg2(b, c)

class Poly1DShifted(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, poly: "Poly1D", shift: "long double const"):
        _asepy.Poly1DShifted_swiginit(self, _asepy.new_Poly1DShifted(poly, shift))

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.Poly1DShifted___call__(self, x)
    __swig_destroy__ = _asepy.delete_Poly1DShifted

# Register Poly1DShifted in _asepy:
_asepy.Poly1DShifted_swigregister(Poly1DShifted)

class QuinticInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, sigmaPlus: "double", yPlus: "double", sigmaMinus: "double", yMinus: "double"):
        _asepy.QuinticInner_swiginit(self, _asepy.new_QuinticInner(sigmaPlus, yPlus, sigmaMinus, yMinus))

    def __call__(self, x: "double") -> "double":
        return _asepy.QuinticInner___call__(self, x)

    def derivative(self, x: "double") -> "double":
        return _asepy.QuinticInner_derivative(self, x)

    def secondDerivative(self, x: "double") -> "double":
        return _asepy.QuinticInner_secondDerivative(self, x)

    def derivPoly(self) -> "ase::Poly1D const &":
        return _asepy.QuinticInner_derivPoly(self)
    __swig_destroy__ = _asepy.delete_QuinticInner

# Register QuinticInner in _asepy:
_asepy.QuinticInner_swigregister(QuinticInner)

class DerivativeFunctorHelper_TransitionCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "TransitionCubic"):
        _asepy.DerivativeFunctorHelper_TransitionCubic_swiginit(self, _asepy.new_DerivativeFunctorHelper_TransitionCubic(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_TransitionCubic___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_TransitionCubic

# Register DerivativeFunctorHelper_TransitionCubic in _asepy:
_asepy.DerivativeFunctorHelper_TransitionCubic_swigregister(DerivativeFunctorHelper_TransitionCubic)

class SecondDerivativeFunctorHelper_TransitionCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "TransitionCubic"):
        _asepy.SecondDerivativeFunctorHelper_TransitionCubic_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_TransitionCubic(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_TransitionCubic___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_TransitionCubic

# Register SecondDerivativeFunctorHelper_TransitionCubic in _asepy:
_asepy.SecondDerivativeFunctorHelper_TransitionCubic_swigregister(SecondDerivativeFunctorHelper_TransitionCubic)

class DerivativeFunctorHelper_ParabolicRailwayCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "ParabolicRailwayCurve"):
        _asepy.DerivativeFunctorHelper_ParabolicRailwayCurve_swiginit(self, _asepy.new_DerivativeFunctorHelper_ParabolicRailwayCurve(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_ParabolicRailwayCurve___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_ParabolicRailwayCurve

# Register DerivativeFunctorHelper_ParabolicRailwayCurve in _asepy:
_asepy.DerivativeFunctorHelper_ParabolicRailwayCurve_swigregister(DerivativeFunctorHelper_ParabolicRailwayCurve)

class SecondDerivativeFunctorHelper_ParabolicRailwayCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "ParabolicRailwayCurve"):
        _asepy.SecondDerivativeFunctorHelper_ParabolicRailwayCurve_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_ParabolicRailwayCurve(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_ParabolicRailwayCurve___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_ParabolicRailwayCurve

# Register SecondDerivativeFunctorHelper_ParabolicRailwayCurve in _asepy:
_asepy.SecondDerivativeFunctorHelper_ParabolicRailwayCurve_swigregister(SecondDerivativeFunctorHelper_ParabolicRailwayCurve)

class DerivativeFunctorHelper_SmoothDoubleCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "SmoothDoubleCubic"):
        _asepy.DerivativeFunctorHelper_SmoothDoubleCubic_swiginit(self, _asepy.new_DerivativeFunctorHelper_SmoothDoubleCubic(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_SmoothDoubleCubic___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_SmoothDoubleCubic

# Register DerivativeFunctorHelper_SmoothDoubleCubic in _asepy:
_asepy.DerivativeFunctorHelper_SmoothDoubleCubic_swigregister(DerivativeFunctorHelper_SmoothDoubleCubic)

class SecondDerivativeFunctorHelper_SmoothDoubleCubic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "SmoothDoubleCubic"):
        _asepy.SecondDerivativeFunctorHelper_SmoothDoubleCubic_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_SmoothDoubleCubic(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_SmoothDoubleCubic___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_SmoothDoubleCubic

# Register SecondDerivativeFunctorHelper_SmoothDoubleCubic in _asepy:
_asepy.SecondDerivativeFunctorHelper_SmoothDoubleCubic_swigregister(SecondDerivativeFunctorHelper_SmoothDoubleCubic)

class DerivativeFunctorHelper_SymbetaDoubleIntegral(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "SymbetaDoubleIntegral"):
        _asepy.DerivativeFunctorHelper_SymbetaDoubleIntegral_swiginit(self, _asepy.new_DerivativeFunctorHelper_SymbetaDoubleIntegral(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_SymbetaDoubleIntegral___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_SymbetaDoubleIntegral

# Register DerivativeFunctorHelper_SymbetaDoubleIntegral in _asepy:
_asepy.DerivativeFunctorHelper_SymbetaDoubleIntegral_swigregister(DerivativeFunctorHelper_SymbetaDoubleIntegral)

class SecondDerivativeFunctorHelper_SymbetaDoubleIntegral(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "SymbetaDoubleIntegral"):
        _asepy.SecondDerivativeFunctorHelper_SymbetaDoubleIntegral_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_SymbetaDoubleIntegral(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_SymbetaDoubleIntegral___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_SymbetaDoubleIntegral

# Register SecondDerivativeFunctorHelper_SymbetaDoubleIntegral in _asepy:
_asepy.SecondDerivativeFunctorHelper_SymbetaDoubleIntegral_swigregister(SecondDerivativeFunctorHelper_SymbetaDoubleIntegral)

class DerivativeFunctorHelper_DoubleCubicInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "DoubleCubicInner"):
        _asepy.DerivativeFunctorHelper_DoubleCubicInner_swiginit(self, _asepy.new_DerivativeFunctorHelper_DoubleCubicInner(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_DoubleCubicInner___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_DoubleCubicInner

# Register DerivativeFunctorHelper_DoubleCubicInner in _asepy:
_asepy.DerivativeFunctorHelper_DoubleCubicInner_swigregister(DerivativeFunctorHelper_DoubleCubicInner)

class SecondDerivativeFunctorHelper_DoubleCubicInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "DoubleCubicInner"):
        _asepy.SecondDerivativeFunctorHelper_DoubleCubicInner_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_DoubleCubicInner(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_DoubleCubicInner___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_DoubleCubicInner

# Register SecondDerivativeFunctorHelper_DoubleCubicInner in _asepy:
_asepy.SecondDerivativeFunctorHelper_DoubleCubicInner_swigregister(SecondDerivativeFunctorHelper_DoubleCubicInner)

class DerivativeFunctorHelper_QuinticInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "QuinticInner"):
        _asepy.DerivativeFunctorHelper_QuinticInner_swiginit(self, _asepy.new_DerivativeFunctorHelper_QuinticInner(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DerivativeFunctorHelper_QuinticInner___call__(self, x)
    __swig_destroy__ = _asepy.delete_DerivativeFunctorHelper_QuinticInner

# Register DerivativeFunctorHelper_QuinticInner in _asepy:
_asepy.DerivativeFunctorHelper_QuinticInner_swigregister(DerivativeFunctorHelper_QuinticInner)


def DerivativeFunctor(*args) -> "ase::DerivativeFunctorHelper< ase::QuinticInner >":
    return _asepy.DerivativeFunctor(*args)
class SecondDerivativeFunctorHelper_QuinticInner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, t: "QuinticInner"):
        _asepy.SecondDerivativeFunctorHelper_QuinticInner_swiginit(self, _asepy.new_SecondDerivativeFunctorHelper_QuinticInner(t))

    def __call__(self, x: "double const") -> "double":
        return _asepy.SecondDerivativeFunctorHelper_QuinticInner___call__(self, x)
    __swig_destroy__ = _asepy.delete_SecondDerivativeFunctorHelper_QuinticInner

# Register SecondDerivativeFunctorHelper_QuinticInner in _asepy:
_asepy.SecondDerivativeFunctorHelper_QuinticInner_swigregister(SecondDerivativeFunctorHelper_QuinticInner)


def SecondDerivativeFunctor(*args) -> "ase::SecondDerivativeFunctorHelper< ase::QuinticInner >":
    return _asepy.SecondDerivativeFunctor(*args)
class PoissonLogli(AbsLogLikelihoodCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_n: "unsigned long const"):
        _asepy.PoissonLogli_swiginit(self, _asepy.new_PoissonLogli(i_n))
    __swig_destroy__ = _asepy.delete_PoissonLogli

    def clone(self) -> "ase::PoissonLogli *":
        return _asepy.PoissonLogli_clone(self)

    def n(self) -> "unsigned long":
        return _asepy.PoissonLogli_n(self)

    def parMin(self) -> "double":
        return _asepy.PoissonLogli_parMin(self)

    def parMax(self) -> "double":
        return _asepy.PoissonLogli_parMax(self)

    def location(self) -> "double":
        return _asepy.PoissonLogli_location(self)

    def stepSize(self) -> "double":
        return _asepy.PoissonLogli_stepSize(self)

    def maximum(self) -> "double":
        return _asepy.PoissonLogli_maximum(self)

    def argmax(self) -> "double":
        return _asepy.PoissonLogli_argmax(self)

    def __call__(self, lam: "double") -> "double":
        return _asepy.PoissonLogli___call__(self, lam)

    def derivative(self, lam: "double") -> "double":
        return _asepy.PoissonLogli_derivative(self, lam)

    def secondDerivative(self, lam: "double", step: "double"=0.0) -> "double":
        return _asepy.PoissonLogli_secondDerivative(self, lam, step)

    def classname(self) -> "std::string":
        return _asepy.PoissonLogli_classname(self)

    def __imul__(self, c: "double const") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.PoissonLogli___imul__(self, c)

    def sigmaMinus(self, deltaLogLi: "double"=0.5, stepFactor: "double"=1.1) -> "double":
        return _asepy.PoissonLogli_sigmaMinus(self, deltaLogLi, stepFactor)

    def posteriorMean(self) -> "double":
        return _asepy.PoissonLogli_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.PoissonLogli_posteriorVariance(self)

# Register PoissonLogli in _asepy:
_asepy.PoissonLogli_swigregister(PoissonLogli)

class SymmetricBetaGaussian(OPATGaussian0):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_swiginit(self, _asepy.new_SymmetricBetaGaussian(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian *":
        return _asepy.SymmetricBetaGaussian_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian

    def p(self) -> "unsigned int":
        return _asepy.SymmetricBetaGaussian_p(self)

    def h(self) -> "double":
        return _asepy.SymmetricBetaGaussian_h(self)

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_classname(self)

    @staticmethod
    def minQuantileRatio(p: "unsigned int", h: "double") -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_minQuantileRatio(p, h)

    @staticmethod
    def minDescentDeltaRatio(p: "unsigned int", h: "double", deltaLnL: "double"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_minDescentDeltaRatio(p, h, deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const", p: "unsigned int const", h: "double const") -> "ase::SymmetricBetaGaussian *":
        return _asepy.SymmetricBetaGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus, p, h)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", p: "unsigned int const", h: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian *":
        return _asepy.SymmetricBetaGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, p, h, deltaLnL)

# Register SymmetricBetaGaussian in _asepy:
_asepy.SymmetricBetaGaussian_swigregister(SymmetricBetaGaussian)

def SymmetricBetaGaussian_minQuantileRatio(p: "unsigned int", h: "double") -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_minQuantileRatio(p, h)

def SymmetricBetaGaussian_minDescentDeltaRatio(p: "unsigned int", h: "double", deltaLnL: "double"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_minDescentDeltaRatio(p, h, deltaLnL)

def SymmetricBetaGaussian_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const", p: "unsigned int const", h: "double const") -> "ase::SymmetricBetaGaussian *":
    return _asepy.SymmetricBetaGaussian_fromQuantiles(median, sigmaPlus, sigmaMinus, p, h)

def SymmetricBetaGaussian_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", p: "unsigned int const", h: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian *":
    return _asepy.SymmetricBetaGaussian_fromModeAndDeltas(mode, deltaPlus, deltaMinus, p, h, deltaLnL)

class SymmetricBetaGaussian_1_10(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_1_10_swiginit(self, _asepy.new_SymmetricBetaGaussian_1_10(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 1U,10U > *":
        return _asepy.SymmetricBetaGaussian_1_10_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_1_10

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_1_10_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_10_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_10_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,10U > *":
        return _asepy.SymmetricBetaGaussian_1_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,10U > *":
        return _asepy.SymmetricBetaGaussian_1_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_1_10 in _asepy:
_asepy.SymmetricBetaGaussian_1_10_swigregister(SymmetricBetaGaussian_1_10)

def SymmetricBetaGaussian_1_10_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_10_minQuantileRatio()

def SymmetricBetaGaussian_1_10_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_10_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_1_10_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,10U > *":
    return _asepy.SymmetricBetaGaussian_1_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_1_10_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,10U > *":
    return _asepy.SymmetricBetaGaussian_1_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_1_15(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_1_15_swiginit(self, _asepy.new_SymmetricBetaGaussian_1_15(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 1U,15U > *":
        return _asepy.SymmetricBetaGaussian_1_15_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_1_15

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_1_15_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_15_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_15_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,15U > *":
        return _asepy.SymmetricBetaGaussian_1_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,15U > *":
        return _asepy.SymmetricBetaGaussian_1_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_1_15 in _asepy:
_asepy.SymmetricBetaGaussian_1_15_swigregister(SymmetricBetaGaussian_1_15)

def SymmetricBetaGaussian_1_15_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_15_minQuantileRatio()

def SymmetricBetaGaussian_1_15_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_15_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_1_15_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,15U > *":
    return _asepy.SymmetricBetaGaussian_1_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_1_15_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,15U > *":
    return _asepy.SymmetricBetaGaussian_1_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_1_20(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_1_20_swiginit(self, _asepy.new_SymmetricBetaGaussian_1_20(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 1U,20U > *":
        return _asepy.SymmetricBetaGaussian_1_20_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_1_20

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_1_20_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_20_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_20_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,20U > *":
        return _asepy.SymmetricBetaGaussian_1_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,20U > *":
        return _asepy.SymmetricBetaGaussian_1_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_1_20 in _asepy:
_asepy.SymmetricBetaGaussian_1_20_swigregister(SymmetricBetaGaussian_1_20)

def SymmetricBetaGaussian_1_20_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_20_minQuantileRatio()

def SymmetricBetaGaussian_1_20_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_20_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_1_20_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,20U > *":
    return _asepy.SymmetricBetaGaussian_1_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_1_20_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,20U > *":
    return _asepy.SymmetricBetaGaussian_1_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_1_25(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_1_25_swiginit(self, _asepy.new_SymmetricBetaGaussian_1_25(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 1U,25U > *":
        return _asepy.SymmetricBetaGaussian_1_25_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_1_25

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_1_25_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_25_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_25_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,25U > *":
        return _asepy.SymmetricBetaGaussian_1_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,25U > *":
        return _asepy.SymmetricBetaGaussian_1_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_1_25 in _asepy:
_asepy.SymmetricBetaGaussian_1_25_swigregister(SymmetricBetaGaussian_1_25)

def SymmetricBetaGaussian_1_25_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_25_minQuantileRatio()

def SymmetricBetaGaussian_1_25_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_25_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_1_25_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,25U > *":
    return _asepy.SymmetricBetaGaussian_1_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_1_25_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,25U > *":
    return _asepy.SymmetricBetaGaussian_1_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_1_30(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_1_30_swiginit(self, _asepy.new_SymmetricBetaGaussian_1_30(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 1U,30U > *":
        return _asepy.SymmetricBetaGaussian_1_30_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_1_30

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_1_30_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_30_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_1_30_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,30U > *":
        return _asepy.SymmetricBetaGaussian_1_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,30U > *":
        return _asepy.SymmetricBetaGaussian_1_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_1_30 in _asepy:
_asepy.SymmetricBetaGaussian_1_30_swigregister(SymmetricBetaGaussian_1_30)

def SymmetricBetaGaussian_1_30_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_30_minQuantileRatio()

def SymmetricBetaGaussian_1_30_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_1_30_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_1_30_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 1U,30U > *":
    return _asepy.SymmetricBetaGaussian_1_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_1_30_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 1U,30U > *":
    return _asepy.SymmetricBetaGaussian_1_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_2_10(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_2_10_swiginit(self, _asepy.new_SymmetricBetaGaussian_2_10(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 2U,10U > *":
        return _asepy.SymmetricBetaGaussian_2_10_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_2_10

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_2_10_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_10_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_10_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,10U > *":
        return _asepy.SymmetricBetaGaussian_2_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,10U > *":
        return _asepy.SymmetricBetaGaussian_2_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_2_10 in _asepy:
_asepy.SymmetricBetaGaussian_2_10_swigregister(SymmetricBetaGaussian_2_10)

def SymmetricBetaGaussian_2_10_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_10_minQuantileRatio()

def SymmetricBetaGaussian_2_10_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_10_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_2_10_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,10U > *":
    return _asepy.SymmetricBetaGaussian_2_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_2_10_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,10U > *":
    return _asepy.SymmetricBetaGaussian_2_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_2_15(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_2_15_swiginit(self, _asepy.new_SymmetricBetaGaussian_2_15(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 2U,15U > *":
        return _asepy.SymmetricBetaGaussian_2_15_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_2_15

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_2_15_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_15_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_15_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,15U > *":
        return _asepy.SymmetricBetaGaussian_2_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,15U > *":
        return _asepy.SymmetricBetaGaussian_2_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_2_15 in _asepy:
_asepy.SymmetricBetaGaussian_2_15_swigregister(SymmetricBetaGaussian_2_15)

def SymmetricBetaGaussian_2_15_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_15_minQuantileRatio()

def SymmetricBetaGaussian_2_15_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_15_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_2_15_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,15U > *":
    return _asepy.SymmetricBetaGaussian_2_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_2_15_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,15U > *":
    return _asepy.SymmetricBetaGaussian_2_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_2_20(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_2_20_swiginit(self, _asepy.new_SymmetricBetaGaussian_2_20(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 2U,20U > *":
        return _asepy.SymmetricBetaGaussian_2_20_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_2_20

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_2_20_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_20_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_20_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,20U > *":
        return _asepy.SymmetricBetaGaussian_2_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,20U > *":
        return _asepy.SymmetricBetaGaussian_2_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_2_20 in _asepy:
_asepy.SymmetricBetaGaussian_2_20_swigregister(SymmetricBetaGaussian_2_20)

def SymmetricBetaGaussian_2_20_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_20_minQuantileRatio()

def SymmetricBetaGaussian_2_20_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_20_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_2_20_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,20U > *":
    return _asepy.SymmetricBetaGaussian_2_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_2_20_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,20U > *":
    return _asepy.SymmetricBetaGaussian_2_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_2_25(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_2_25_swiginit(self, _asepy.new_SymmetricBetaGaussian_2_25(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 2U,25U > *":
        return _asepy.SymmetricBetaGaussian_2_25_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_2_25

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_2_25_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_25_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_25_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,25U > *":
        return _asepy.SymmetricBetaGaussian_2_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,25U > *":
        return _asepy.SymmetricBetaGaussian_2_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_2_25 in _asepy:
_asepy.SymmetricBetaGaussian_2_25_swigregister(SymmetricBetaGaussian_2_25)

def SymmetricBetaGaussian_2_25_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_25_minQuantileRatio()

def SymmetricBetaGaussian_2_25_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_25_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_2_25_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,25U > *":
    return _asepy.SymmetricBetaGaussian_2_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_2_25_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,25U > *":
    return _asepy.SymmetricBetaGaussian_2_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_2_30(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_2_30_swiginit(self, _asepy.new_SymmetricBetaGaussian_2_30(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 2U,30U > *":
        return _asepy.SymmetricBetaGaussian_2_30_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_2_30

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_2_30_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_30_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_2_30_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,30U > *":
        return _asepy.SymmetricBetaGaussian_2_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,30U > *":
        return _asepy.SymmetricBetaGaussian_2_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_2_30 in _asepy:
_asepy.SymmetricBetaGaussian_2_30_swigregister(SymmetricBetaGaussian_2_30)

def SymmetricBetaGaussian_2_30_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_30_minQuantileRatio()

def SymmetricBetaGaussian_2_30_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_2_30_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_2_30_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 2U,30U > *":
    return _asepy.SymmetricBetaGaussian_2_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_2_30_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 2U,30U > *":
    return _asepy.SymmetricBetaGaussian_2_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_3_10(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_3_10_swiginit(self, _asepy.new_SymmetricBetaGaussian_3_10(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 3U,10U > *":
        return _asepy.SymmetricBetaGaussian_3_10_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_3_10

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_3_10_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_10_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_10_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,10U > *":
        return _asepy.SymmetricBetaGaussian_3_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,10U > *":
        return _asepy.SymmetricBetaGaussian_3_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_3_10 in _asepy:
_asepy.SymmetricBetaGaussian_3_10_swigregister(SymmetricBetaGaussian_3_10)

def SymmetricBetaGaussian_3_10_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_10_minQuantileRatio()

def SymmetricBetaGaussian_3_10_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_10_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_3_10_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,10U > *":
    return _asepy.SymmetricBetaGaussian_3_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_3_10_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,10U > *":
    return _asepy.SymmetricBetaGaussian_3_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_3_15(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_3_15_swiginit(self, _asepy.new_SymmetricBetaGaussian_3_15(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 3U,15U > *":
        return _asepy.SymmetricBetaGaussian_3_15_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_3_15

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_3_15_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_15_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_15_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,15U > *":
        return _asepy.SymmetricBetaGaussian_3_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,15U > *":
        return _asepy.SymmetricBetaGaussian_3_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_3_15 in _asepy:
_asepy.SymmetricBetaGaussian_3_15_swigregister(SymmetricBetaGaussian_3_15)

def SymmetricBetaGaussian_3_15_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_15_minQuantileRatio()

def SymmetricBetaGaussian_3_15_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_15_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_3_15_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,15U > *":
    return _asepy.SymmetricBetaGaussian_3_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_3_15_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,15U > *":
    return _asepy.SymmetricBetaGaussian_3_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_3_20(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_3_20_swiginit(self, _asepy.new_SymmetricBetaGaussian_3_20(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 3U,20U > *":
        return _asepy.SymmetricBetaGaussian_3_20_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_3_20

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_3_20_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_20_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_20_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,20U > *":
        return _asepy.SymmetricBetaGaussian_3_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,20U > *":
        return _asepy.SymmetricBetaGaussian_3_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_3_20 in _asepy:
_asepy.SymmetricBetaGaussian_3_20_swigregister(SymmetricBetaGaussian_3_20)

def SymmetricBetaGaussian_3_20_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_20_minQuantileRatio()

def SymmetricBetaGaussian_3_20_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_20_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_3_20_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,20U > *":
    return _asepy.SymmetricBetaGaussian_3_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_3_20_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,20U > *":
    return _asepy.SymmetricBetaGaussian_3_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_3_25(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_3_25_swiginit(self, _asepy.new_SymmetricBetaGaussian_3_25(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 3U,25U > *":
        return _asepy.SymmetricBetaGaussian_3_25_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_3_25

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_3_25_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_25_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_25_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,25U > *":
        return _asepy.SymmetricBetaGaussian_3_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,25U > *":
        return _asepy.SymmetricBetaGaussian_3_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_3_25 in _asepy:
_asepy.SymmetricBetaGaussian_3_25_swigregister(SymmetricBetaGaussian_3_25)

def SymmetricBetaGaussian_3_25_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_25_minQuantileRatio()

def SymmetricBetaGaussian_3_25_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_25_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_3_25_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,25U > *":
    return _asepy.SymmetricBetaGaussian_3_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_3_25_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,25U > *":
    return _asepy.SymmetricBetaGaussian_3_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_3_30(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_3_30_swiginit(self, _asepy.new_SymmetricBetaGaussian_3_30(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 3U,30U > *":
        return _asepy.SymmetricBetaGaussian_3_30_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_3_30

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_3_30_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_30_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_3_30_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,30U > *":
        return _asepy.SymmetricBetaGaussian_3_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,30U > *":
        return _asepy.SymmetricBetaGaussian_3_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_3_30 in _asepy:
_asepy.SymmetricBetaGaussian_3_30_swigregister(SymmetricBetaGaussian_3_30)

def SymmetricBetaGaussian_3_30_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_30_minQuantileRatio()

def SymmetricBetaGaussian_3_30_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_3_30_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_3_30_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 3U,30U > *":
    return _asepy.SymmetricBetaGaussian_3_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_3_30_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 3U,30U > *":
    return _asepy.SymmetricBetaGaussian_3_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_4_10(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_4_10_swiginit(self, _asepy.new_SymmetricBetaGaussian_4_10(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 4U,10U > *":
        return _asepy.SymmetricBetaGaussian_4_10_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_4_10

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_4_10_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_10_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_10_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,10U > *":
        return _asepy.SymmetricBetaGaussian_4_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,10U > *":
        return _asepy.SymmetricBetaGaussian_4_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_4_10 in _asepy:
_asepy.SymmetricBetaGaussian_4_10_swigregister(SymmetricBetaGaussian_4_10)

def SymmetricBetaGaussian_4_10_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_10_minQuantileRatio()

def SymmetricBetaGaussian_4_10_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_10_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_4_10_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,10U > *":
    return _asepy.SymmetricBetaGaussian_4_10_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_4_10_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,10U > *":
    return _asepy.SymmetricBetaGaussian_4_10_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_4_15(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_4_15_swiginit(self, _asepy.new_SymmetricBetaGaussian_4_15(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 4U,15U > *":
        return _asepy.SymmetricBetaGaussian_4_15_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_4_15

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_4_15_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_15_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_15_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,15U > *":
        return _asepy.SymmetricBetaGaussian_4_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,15U > *":
        return _asepy.SymmetricBetaGaussian_4_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_4_15 in _asepy:
_asepy.SymmetricBetaGaussian_4_15_swigregister(SymmetricBetaGaussian_4_15)

def SymmetricBetaGaussian_4_15_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_15_minQuantileRatio()

def SymmetricBetaGaussian_4_15_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_15_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_4_15_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,15U > *":
    return _asepy.SymmetricBetaGaussian_4_15_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_4_15_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,15U > *":
    return _asepy.SymmetricBetaGaussian_4_15_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_4_20(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_4_20_swiginit(self, _asepy.new_SymmetricBetaGaussian_4_20(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 4U,20U > *":
        return _asepy.SymmetricBetaGaussian_4_20_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_4_20

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_4_20_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_20_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_20_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,20U > *":
        return _asepy.SymmetricBetaGaussian_4_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,20U > *":
        return _asepy.SymmetricBetaGaussian_4_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_4_20 in _asepy:
_asepy.SymmetricBetaGaussian_4_20_swigregister(SymmetricBetaGaussian_4_20)

def SymmetricBetaGaussian_4_20_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_20_minQuantileRatio()

def SymmetricBetaGaussian_4_20_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_20_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_4_20_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,20U > *":
    return _asepy.SymmetricBetaGaussian_4_20_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_4_20_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,20U > *":
    return _asepy.SymmetricBetaGaussian_4_20_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_4_25(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_4_25_swiginit(self, _asepy.new_SymmetricBetaGaussian_4_25(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 4U,25U > *":
        return _asepy.SymmetricBetaGaussian_4_25_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_4_25

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_4_25_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_25_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_25_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,25U > *":
        return _asepy.SymmetricBetaGaussian_4_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,25U > *":
        return _asepy.SymmetricBetaGaussian_4_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_4_25 in _asepy:
_asepy.SymmetricBetaGaussian_4_25_swigregister(SymmetricBetaGaussian_4_25)

def SymmetricBetaGaussian_4_25_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_25_minQuantileRatio()

def SymmetricBetaGaussian_4_25_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_25_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_4_25_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,25U > *":
    return _asepy.SymmetricBetaGaussian_4_25_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_4_25_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,25U > *":
    return _asepy.SymmetricBetaGaussian_4_25_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

class SymmetricBetaGaussian_4_30(SymmetricBetaGaussian):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.SymmetricBetaGaussian_4_30_swiginit(self, _asepy.new_SymmetricBetaGaussian_4_30(*args))

    def clone(self) -> "ase::SymmetricBetaGaussian_p_h< 4U,30U > *":
        return _asepy.SymmetricBetaGaussian_4_30_clone(self)
    __swig_destroy__ = _asepy.delete_SymmetricBetaGaussian_4_30

    def classname(self) -> "std::string":
        return _asepy.SymmetricBetaGaussian_4_30_classname(self)

    @staticmethod
    def minQuantileRatio() -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_30_minQuantileRatio()

    @staticmethod
    def minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
        return _asepy.SymmetricBetaGaussian_4_30_minDescentDeltaRatio(deltaLnL)

    @staticmethod
    def fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,30U > *":
        return _asepy.SymmetricBetaGaussian_4_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

    @staticmethod
    def fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,30U > *":
        return _asepy.SymmetricBetaGaussian_4_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)

# Register SymmetricBetaGaussian_4_30 in _asepy:
_asepy.SymmetricBetaGaussian_4_30_swigregister(SymmetricBetaGaussian_4_30)

def SymmetricBetaGaussian_4_30_minQuantileRatio() -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_30_minQuantileRatio()

def SymmetricBetaGaussian_4_30_minDescentDeltaRatio(deltaLnL: "double const"=0.5) -> "std::pair< double,double >":
    return _asepy.SymmetricBetaGaussian_4_30_minDescentDeltaRatio(deltaLnL)

def SymmetricBetaGaussian_4_30_fromQuantiles(median: "double const", sigmaPlus: "double const", sigmaMinus: "double const") -> "ase::SymmetricBetaGaussian_p_h< 4U,30U > *":
    return _asepy.SymmetricBetaGaussian_4_30_fromQuantiles(median, sigmaPlus, sigmaMinus)

def SymmetricBetaGaussian_4_30_fromModeAndDeltas(mode: "double const", deltaPlus: "double const", deltaMinus: "double const", deltaLnL: "double const"=0.5) -> "ase::SymmetricBetaGaussian_p_h< 4U,30U > *":
    return _asepy.SymmetricBetaGaussian_4_30_fromModeAndDeltas(mode, deltaPlus, deltaMinus, deltaLnL)


def arrayCumulants(arr: "double const *", maxOrder: "unsigned int const") -> "std::vector< double,std::allocator< double > >":
    return _asepy.arrayCumulants(arr, maxOrder)

def densityIntegralGL(distro: "AbsDistributionModel1D", xmin: "double", xmax: "double", nPt: "unsigned int", nIntervals: "unsigned int"=1) -> "double":
    return _asepy.densityIntegralGL(distro, xmin, xmax, nPt, nIntervals)
class TabulatedDensity1D(AbsLocationScaleFamily):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.TabulatedDensity1D_isFullOPAT

    def clone(self) -> "ase::TabulatedDensity1D *":
        return _asepy.TabulatedDensity1D_clone(self)
    __swig_destroy__ = _asepy.delete_TabulatedDensity1D

    def isUnimodal(self) -> "bool":
        return _asepy.TabulatedDensity1D_isUnimodal(self)

    def classname(self) -> "std::string":
        return _asepy.TabulatedDensity1D_classname(self)

    def entropy(self) -> "double":
        return _asepy.TabulatedDensity1D_entropy(self)

    def nCoords(self) -> "unsigned int":
        return _asepy.TabulatedDensity1D_nCoords(self)

    def __init__(self, *args):
        _asepy.TabulatedDensity1D_swiginit(self, _asepy.new_TabulatedDensity1D(*args))

# Register TabulatedDensity1D in _asepy:
_asepy.TabulatedDensity1D_swigregister(TabulatedDensity1D)

class LikelihoodAccumulator(AbsLogLikelihoodCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _asepy.LikelihoodAccumulator_swiginit(self, _asepy.new_LikelihoodAccumulator())
    __swig_destroy__ = _asepy.delete_LikelihoodAccumulator

    def clone(self) -> "ase::LikelihoodAccumulator *":
        return _asepy.LikelihoodAccumulator_clone(self)

    def empty(self) -> "bool":
        return _asepy.LikelihoodAccumulator_empty(self)

    def size(self) -> "unsigned int":
        return _asepy.LikelihoodAccumulator_size(self)

    def getCurve(self, i: "unsigned int const") -> "ase::LikelihoodCurveCopy":
        return _asepy.LikelihoodAccumulator_getCurve(self, i)

    def factor(self) -> "double":
        return _asepy.LikelihoodAccumulator_factor(self)

    def accumulate(self, r: "AbsLogLikelihoodCurve") -> "void":
        return _asepy.LikelihoodAccumulator_accumulate(self, r)

    def __iadd__(self, r: "AbsLogLikelihoodCurve") -> "ase::LikelihoodAccumulator &":
        return _asepy.LikelihoodAccumulator___iadd__(self, r)

    def __isub__(self, r: "AbsLogLikelihoodCurve") -> "ase::LikelihoodAccumulator &":
        return _asepy.LikelihoodAccumulator___isub__(self, r)

    def parMin(self) -> "double":
        return _asepy.LikelihoodAccumulator_parMin(self)

    def parMax(self) -> "double":
        return _asepy.LikelihoodAccumulator_parMax(self)

    def location(self) -> "double":
        return _asepy.LikelihoodAccumulator_location(self)

    def stepSize(self) -> "double":
        return _asepy.LikelihoodAccumulator_stepSize(self)

    def maximum(self) -> "double":
        return _asepy.LikelihoodAccumulator_maximum(self)

    def argmax(self) -> "double":
        return _asepy.LikelihoodAccumulator_argmax(self)

    def __call__(self, parameter: "double") -> "double":
        return _asepy.LikelihoodAccumulator___call__(self, parameter)

    def derivative(self, parameter: "double") -> "double":
        return _asepy.LikelihoodAccumulator_derivative(self, parameter)

    def secondDerivative(self, parameter: "double", step: "double"=0.0) -> "double":
        return _asepy.LikelihoodAccumulator_secondDerivative(self, parameter, step)

    def classname(self) -> "std::string":
        return _asepy.LikelihoodAccumulator_classname(self)

    def __imul__(self, c: "double const") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.LikelihoodAccumulator___imul__(self, c)

# Register LikelihoodAccumulator in _asepy:
_asepy.LikelihoodAccumulator_swigregister(LikelihoodAccumulator)

class AbsShiftableLogli(AbsLogLikelihoodCurve):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_AbsShiftableLogli

    def clone(self) -> "ase::AbsShiftableLogli *":
        return _asepy.AbsShiftableLogli_clone(self)

    def shift(self) -> "double":
        return _asepy.AbsShiftableLogli_shift(self)

    def factor(self) -> "double":
        return _asepy.AbsShiftableLogli_factor(self)

    def setShift(self, s: "double const") -> "void":
        return _asepy.AbsShiftableLogli_setShift(self, s)

    def setFactor(self, f: "double const") -> "void":
        return _asepy.AbsShiftableLogli_setFactor(self, f)

    def parMin(self) -> "double":
        return _asepy.AbsShiftableLogli_parMin(self)

    def parMax(self) -> "double":
        return _asepy.AbsShiftableLogli_parMax(self)

    def location(self) -> "double":
        return _asepy.AbsShiftableLogli_location(self)

    def stepSize(self) -> "double":
        return _asepy.AbsShiftableLogli_stepSize(self)

    def maximum(self) -> "double":
        return _asepy.AbsShiftableLogli_maximum(self)

    def argmax(self) -> "double":
        return _asepy.AbsShiftableLogli_argmax(self)

    def __call__(self, p: "double const") -> "double":
        return _asepy.AbsShiftableLogli___call__(self, p)

    def derivative(self, p: "double const") -> "double":
        return _asepy.AbsShiftableLogli_derivative(self, p)

    def secondDerivative(self, p: "double const", step: "double const"=0.0) -> "double":
        return _asepy.AbsShiftableLogli_secondDerivative(self, p, step)

    def classname(self) -> "std::string":
        return _asepy.AbsShiftableLogli_classname(self)

    def __imul__(self, c: "double const") -> "ase::AbsLogLikelihoodCurve &":
        return _asepy.AbsShiftableLogli___imul__(self, c)

    def sigmaPlus(self, deltaLogLikelihood: "double"=0.5, stepFactor: "double"=1.1) -> "double":
        return _asepy.AbsShiftableLogli_sigmaPlus(self, deltaLogLikelihood, stepFactor)

    def sigmaMinus(self, deltaLogLikelihood: "double"=0.5, stepFactor: "double"=1.1) -> "double":
        return _asepy.AbsShiftableLogli_sigmaMinus(self, deltaLogLikelihood, stepFactor)

# Register AbsShiftableLogli in _asepy:
_asepy.AbsShiftableLogli_swigregister(AbsShiftableLogli)


def moldingVarianceAt0(sigmaPlus: "double", sigmaMinus: "double", denomPower: "unsigned int") -> "double":
    return _asepy.moldingVarianceAt0(sigmaPlus, sigmaMinus, denomPower)
class SymmetrizedParabola(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.SymmetrizedParabola_swiginit(self, _asepy.new_SymmetrizedParabola(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_SymmetrizedParabola

    def clone(self) -> "ase::SymmetrizedParabola *":
        return _asepy.SymmetrizedParabola_clone(self)

    def stepSize(self) -> "double":
        return _asepy.SymmetrizedParabola_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.SymmetrizedParabola_classname(self)

    def posteriorMean(self) -> "double":
        return _asepy.SymmetrizedParabola_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.SymmetrizedParabola_posteriorVariance(self)

# Register SymmetrizedParabola in _asepy:
_asepy.SymmetrizedParabola_swigregister(SymmetrizedParabola)

class BrokenParabola(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.BrokenParabola_swiginit(self, _asepy.new_BrokenParabola(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_BrokenParabola

    def clone(self) -> "ase::BrokenParabola *":
        return _asepy.BrokenParabola_clone(self)

    def stepSize(self) -> "double":
        return _asepy.BrokenParabola_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.BrokenParabola_classname(self)

# Register BrokenParabola in _asepy:
_asepy.BrokenParabola_swigregister(BrokenParabola)

class TruncatedCubicLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.TruncatedCubicLogli_swiginit(self, _asepy.new_TruncatedCubicLogli(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_TruncatedCubicLogli

    def clone(self) -> "ase::TruncatedCubicLogli *":
        return _asepy.TruncatedCubicLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.TruncatedCubicLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.TruncatedCubicLogli_classname(self)

    def alpha(self) -> "double":
        return _asepy.TruncatedCubicLogli_alpha(self)

    def beta(self) -> "double":
        return _asepy.TruncatedCubicLogli_beta(self)

# Register TruncatedCubicLogli in _asepy:
_asepy.TruncatedCubicLogli_swigregister(TruncatedCubicLogli)

class LogarithmicLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.LogarithmicLogli_swiginit(self, _asepy.new_LogarithmicLogli(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_LogarithmicLogli

    def clone(self) -> "ase::LogarithmicLogli *":
        return _asepy.LogarithmicLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.LogarithmicLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.LogarithmicLogli_classname(self)

# Register LogarithmicLogli in _asepy:
_asepy.LogarithmicLogli_swigregister(LogarithmicLogli)

class GeneralisedPoisson(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, i_location: "double const", i_sigmaPlus: "double const", i_sigmaMinus: "double const"):
        _asepy.GeneralisedPoisson_swiginit(self, _asepy.new_GeneralisedPoisson(i_location, i_sigmaPlus, i_sigmaMinus))
    __swig_destroy__ = _asepy.delete_GeneralisedPoisson

    def clone(self) -> "ase::GeneralisedPoisson *":
        return _asepy.GeneralisedPoisson_clone(self)

    def stepSize(self) -> "double":
        return _asepy.GeneralisedPoisson_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.GeneralisedPoisson_classname(self)

    def posteriorMean(self) -> "double":
        return _asepy.GeneralisedPoisson_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.GeneralisedPoisson_posteriorVariance(self)

# Register GeneralisedPoisson in _asepy:
_asepy.GeneralisedPoisson_swigregister(GeneralisedPoisson)

class ConstrainedQuartic(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConstrainedQuartic_swiginit(self, _asepy.new_ConstrainedQuartic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConstrainedQuartic

    def clone(self) -> "ase::ConstrainedQuartic *":
        return _asepy.ConstrainedQuartic_clone(self)

    def alpha(self) -> "double":
        return _asepy.ConstrainedQuartic_alpha(self)

    def beta(self) -> "double":
        return _asepy.ConstrainedQuartic_beta(self)

    def stepSize(self) -> "double":
        return _asepy.ConstrainedQuartic_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.ConstrainedQuartic_classname(self)

# Register ConstrainedQuartic in _asepy:
_asepy.ConstrainedQuartic_swigregister(ConstrainedQuartic)

class MoldedQuartic(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.MoldedQuartic_swiginit(self, _asepy.new_MoldedQuartic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_MoldedQuartic

    def clone(self) -> "ase::MoldedQuartic *":
        return _asepy.MoldedQuartic_clone(self)

    def a(self) -> "double":
        return _asepy.MoldedQuartic_a(self)

    def b(self) -> "double":
        return _asepy.MoldedQuartic_b(self)

    def c(self) -> "double":
        return _asepy.MoldedQuartic_c(self)

    def stepSize(self) -> "double":
        return _asepy.MoldedQuartic_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.MoldedQuartic_classname(self)

# Register MoldedQuartic in _asepy:
_asepy.MoldedQuartic_swigregister(MoldedQuartic)

class MatchedQuintic(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.MatchedQuintic_swiginit(self, _asepy.new_MatchedQuintic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_MatchedQuintic

    def clone(self) -> "ase::MatchedQuintic *":
        return _asepy.MatchedQuintic_clone(self)

    def a(self) -> "double":
        return _asepy.MatchedQuintic_a(self)

    def b(self) -> "double":
        return _asepy.MatchedQuintic_b(self)

    def c(self) -> "double":
        return _asepy.MatchedQuintic_c(self)

    def d(self) -> "double":
        return _asepy.MatchedQuintic_d(self)

    def stepSize(self) -> "double":
        return _asepy.MatchedQuintic_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.MatchedQuintic_classname(self)

# Register MatchedQuintic in _asepy:
_asepy.MatchedQuintic_swigregister(MatchedQuintic)

class DoubleQuartic(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_DoubleQuartic

    def clone(self) -> "ase::AbsShiftableLogli *":
        return _asepy.DoubleQuartic_clone(self)

    def stepSize(self) -> "double":
        return _asepy.DoubleQuartic_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.DoubleQuartic_classname(self)

# Register DoubleQuartic in _asepy:
_asepy.DoubleQuartic_swigregister(DoubleQuartic)

class MoldedDoubleQuartic(DoubleQuartic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double const", sigmaPlus: "double const", sigmaMinus: "double const"):
        _asepy.MoldedDoubleQuartic_swiginit(self, _asepy.new_MoldedDoubleQuartic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_MoldedDoubleQuartic

    def clone(self) -> "ase::MoldedDoubleQuartic *":
        return _asepy.MoldedDoubleQuartic_clone(self)

    def classname(self) -> "std::string":
        return _asepy.MoldedDoubleQuartic_classname(self)

# Register MoldedDoubleQuartic in _asepy:
_asepy.MoldedDoubleQuartic_swigregister(MoldedDoubleQuartic)

class SimpleDoubleQuartic(DoubleQuartic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double const", sigmaPlus: "double const", sigmaMinus: "double const"):
        _asepy.SimpleDoubleQuartic_swiginit(self, _asepy.new_SimpleDoubleQuartic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_SimpleDoubleQuartic

    def clone(self) -> "ase::SimpleDoubleQuartic *":
        return _asepy.SimpleDoubleQuartic_clone(self)

    def classname(self) -> "std::string":
        return _asepy.SimpleDoubleQuartic_classname(self)

# Register SimpleDoubleQuartic in _asepy:
_asepy.SimpleDoubleQuartic_swigregister(SimpleDoubleQuartic)

class DoubleQuintic(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_DoubleQuintic

    def clone(self) -> "ase::AbsShiftableLogli *":
        return _asepy.DoubleQuintic_clone(self)

    def stepSize(self) -> "double":
        return _asepy.DoubleQuintic_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.DoubleQuintic_classname(self)

# Register DoubleQuintic in _asepy:
_asepy.DoubleQuintic_swigregister(DoubleQuintic)

class MoldedDoubleQuintic(DoubleQuintic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double const", sigmaPlus: "double const", sigmaMinus: "double const"):
        _asepy.MoldedDoubleQuintic_swiginit(self, _asepy.new_MoldedDoubleQuintic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_MoldedDoubleQuintic

    def clone(self) -> "ase::MoldedDoubleQuintic *":
        return _asepy.MoldedDoubleQuintic_clone(self)

    def classname(self) -> "std::string":
        return _asepy.MoldedDoubleQuintic_classname(self)

# Register MoldedDoubleQuintic in _asepy:
_asepy.MoldedDoubleQuintic_swigregister(MoldedDoubleQuintic)

class SimpleDoubleQuintic(DoubleQuintic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double const", sigmaPlus: "double const", sigmaMinus: "double const"):
        _asepy.SimpleDoubleQuintic_swiginit(self, _asepy.new_SimpleDoubleQuintic(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_SimpleDoubleQuintic

    def clone(self) -> "ase::SimpleDoubleQuintic *":
        return _asepy.SimpleDoubleQuintic_clone(self)

    def classname(self) -> "std::string":
        return _asepy.SimpleDoubleQuintic_classname(self)

# Register SimpleDoubleQuintic in _asepy:
_asepy.SimpleDoubleQuintic_swigregister(SimpleDoubleQuintic)

class Interpolated7thDegree(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.Interpolated7thDegree_swiginit(self, _asepy.new_Interpolated7thDegree(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_Interpolated7thDegree

    def clone(self) -> "ase::Interpolated7thDegree *":
        return _asepy.Interpolated7thDegree_clone(self)

    def stepSize(self) -> "double":
        return _asepy.Interpolated7thDegree_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.Interpolated7thDegree_classname(self)

# Register Interpolated7thDegree in _asepy:
_asepy.Interpolated7thDegree_swigregister(Interpolated7thDegree)

class VariableSigmaLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.VariableSigmaLogli_swiginit(self, _asepy.new_VariableSigmaLogli(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_VariableSigmaLogli

    def clone(self) -> "ase::VariableSigmaLogli *":
        return _asepy.VariableSigmaLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.VariableSigmaLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.VariableSigmaLogli_classname(self)

# Register VariableSigmaLogli in _asepy:
_asepy.VariableSigmaLogli_swigregister(VariableSigmaLogli)

class VariableVarianceLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.VariableVarianceLogli_swiginit(self, _asepy.new_VariableVarianceLogli(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_VariableVarianceLogli

    def clone(self) -> "ase::VariableVarianceLogli *":
        return _asepy.VariableVarianceLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.VariableVarianceLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.VariableVarianceLogli_classname(self)

# Register VariableVarianceLogli in _asepy:
_asepy.VariableVarianceLogli_swigregister(VariableVarianceLogli)

class VariableLogSigma(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.VariableLogSigma_swiginit(self, _asepy.new_VariableLogSigma(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_VariableLogSigma

    def clone(self) -> "ase::VariableLogSigma *":
        return _asepy.VariableLogSigma_clone(self)

    def stepSize(self) -> "double":
        return _asepy.VariableLogSigma_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.VariableLogSigma_classname(self)

# Register VariableLogSigma in _asepy:
_asepy.VariableLogSigma_swigregister(VariableLogSigma)

class DoubleCubicLogSigma(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_DoubleCubicLogSigma

    def clone(self) -> "ase::DoubleCubicLogSigma *":
        return _asepy.DoubleCubicLogSigma_clone(self)

    def stepSize(self) -> "double":
        return _asepy.DoubleCubicLogSigma_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.DoubleCubicLogSigma_classname(self)

# Register DoubleCubicLogSigma in _asepy:
_asepy.DoubleCubicLogSigma_swigregister(DoubleCubicLogSigma)

class MoldedCubicLogSigma(DoubleCubicLogSigma):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.MoldedCubicLogSigma_swiginit(self, _asepy.new_MoldedCubicLogSigma(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_MoldedCubicLogSigma

    def clone(self) -> "ase::MoldedCubicLogSigma *":
        return _asepy.MoldedCubicLogSigma_clone(self)

    def classname(self) -> "std::string":
        return _asepy.MoldedCubicLogSigma_classname(self)

    @staticmethod
    def getEffectiveSigmaAt0(sigmaPlus: "double", sigmaMinus: "double") -> "double":
        return _asepy.MoldedCubicLogSigma_getEffectiveSigmaAt0(sigmaPlus, sigmaMinus)

# Register MoldedCubicLogSigma in _asepy:
_asepy.MoldedCubicLogSigma_swigregister(MoldedCubicLogSigma)

def MoldedCubicLogSigma_getEffectiveSigmaAt0(sigmaPlus: "double", sigmaMinus: "double") -> "double":
    return _asepy.MoldedCubicLogSigma_getEffectiveSigmaAt0(sigmaPlus, sigmaMinus)

class QuinticLogSigma(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.QuinticLogSigma_swiginit(self, _asepy.new_QuinticLogSigma(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_QuinticLogSigma

    def clone(self) -> "ase::QuinticLogSigma *":
        return _asepy.QuinticLogSigma_clone(self)

    def stepSize(self) -> "double":
        return _asepy.QuinticLogSigma_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.QuinticLogSigma_classname(self)

# Register QuinticLogSigma in _asepy:
_asepy.QuinticLogSigma_swigregister(QuinticLogSigma)

class PDGLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.PDGLogli_swiginit(self, _asepy.new_PDGLogli(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_PDGLogli

    def clone(self) -> "ase::PDGLogli *":
        return _asepy.PDGLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.PDGLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.PDGLogli_classname(self)

# Register PDGLogli in _asepy:
_asepy.PDGLogli_swigregister(PDGLogli)

class LogLogisticBeta(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.LogLogisticBeta_swiginit(self, _asepy.new_LogLogisticBeta(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_LogLogisticBeta

    def clone(self) -> "ase::LogLogisticBeta *":
        return _asepy.LogLogisticBeta_clone(self)

    def stepSize(self) -> "double":
        return _asepy.LogLogisticBeta_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.LogLogisticBeta_classname(self)

# Register LogLogisticBeta in _asepy:
_asepy.LogLogisticBeta_swigregister(LogLogisticBeta)

class DistributionLogli(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, distro: "AbsDistributionModel1D", x0: "double", minDensity: "double"=0.0):
        _asepy.DistributionLogli_swiginit(self, _asepy.new_DistributionLogli(distro, x0, minDensity))
    __swig_destroy__ = _asepy.delete_DistributionLogli

    def clone(self) -> "ase::DistributionLogli *":
        return _asepy.DistributionLogli_clone(self)

    def stepSize(self) -> "double":
        return _asepy.DistributionLogli_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.DistributionLogli_classname(self)

    def x0(self) -> "double":
        return _asepy.DistributionLogli_x0(self)

    def distribution(self) -> "ase::AbsDistributionModel1D const &":
        return _asepy.DistributionLogli_distribution(self)

    def posteriorMean(self) -> "double":
        return _asepy.DistributionLogli_posteriorMean(self)

    def posteriorVariance(self) -> "double":
        return _asepy.DistributionLogli_posteriorVariance(self)

# Register DistributionLogli in _asepy:
_asepy.DistributionLogli_swigregister(DistributionLogli)

class ConservativeSpline(AbsShiftableLogli):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double", secondDerivLimitFactor: "double"):
        _asepy.ConservativeSpline_swiginit(self, _asepy.new_ConservativeSpline(location, sigmaPlus, sigmaMinus, secondDerivLimitFactor))
    __swig_destroy__ = _asepy.delete_ConservativeSpline

    def clone(self) -> "ase::ConservativeSpline *":
        return _asepy.ConservativeSpline_clone(self)

    def stepSize(self) -> "double":
        return _asepy.ConservativeSpline_stepSize(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSpline_classname(self)

    def limitingFactor(self) -> "double":
        return _asepy.ConservativeSpline_limitingFactor(self)

    @staticmethod
    def maxDerivLimitFactor(sigmaPlus: "double", sigmaMinus: "double") -> "double":
        return _asepy.ConservativeSpline_maxDerivLimitFactor(sigmaPlus, sigmaMinus)

# Register ConservativeSpline in _asepy:
_asepy.ConservativeSpline_swigregister(ConservativeSpline)

def ConservativeSpline_maxDerivLimitFactor(sigmaPlus: "double", sigmaMinus: "double") -> "double":
    return _asepy.ConservativeSpline_maxDerivLimitFactor(sigmaPlus, sigmaMinus)

class ConservativeSigma05(ConservativeSpline):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConservativeSigma05_swiginit(self, _asepy.new_ConservativeSigma05(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConservativeSigma05

    def clone(self) -> "ase::ConservativeSigma05 *":
        return _asepy.ConservativeSigma05_clone(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSigma05_classname(self)

# Register ConservativeSigma05 in _asepy:
_asepy.ConservativeSigma05_swigregister(ConservativeSigma05)

class ConservativeSigma10(ConservativeSpline):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConservativeSigma10_swiginit(self, _asepy.new_ConservativeSigma10(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConservativeSigma10

    def clone(self) -> "ase::ConservativeSigma10 *":
        return _asepy.ConservativeSigma10_clone(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSigma10_classname(self)

# Register ConservativeSigma10 in _asepy:
_asepy.ConservativeSigma10_swigregister(ConservativeSigma10)

class ConservativeSigma15(ConservativeSpline):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConservativeSigma15_swiginit(self, _asepy.new_ConservativeSigma15(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConservativeSigma15

    def clone(self) -> "ase::ConservativeSigma15 *":
        return _asepy.ConservativeSigma15_clone(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSigma15_classname(self)

# Register ConservativeSigma15 in _asepy:
_asepy.ConservativeSigma15_swigregister(ConservativeSigma15)

class ConservativeSigma20(ConservativeSpline):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConservativeSigma20_swiginit(self, _asepy.new_ConservativeSigma20(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConservativeSigma20

    def clone(self) -> "ase::ConservativeSigma20 *":
        return _asepy.ConservativeSigma20_clone(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSigma20_classname(self)

# Register ConservativeSigma20 in _asepy:
_asepy.ConservativeSigma20_swigregister(ConservativeSigma20)

class ConservativeSigmaMax(ConservativeSpline):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, location: "double", sigmaPlus: "double", sigmaMinus: "double"):
        _asepy.ConservativeSigmaMax_swiginit(self, _asepy.new_ConservativeSigmaMax(location, sigmaPlus, sigmaMinus))
    __swig_destroy__ = _asepy.delete_ConservativeSigmaMax

    def clone(self) -> "ase::ConservativeSigmaMax *":
        return _asepy.ConservativeSigmaMax_clone(self)

    def classname(self) -> "std::string":
        return _asepy.ConservativeSigmaMax_classname(self)

# Register ConservativeSigmaMax in _asepy:
_asepy.ConservativeSigmaMax_swigregister(ConservativeSigmaMax)

class EquidistantGrid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nCoords: "unsigned int", min: "double", max: "double"):
        _asepy.EquidistantGrid_swiginit(self, _asepy.new_EquidistantGrid(nCoords, min, max))

    def nCoords(self) -> "unsigned int":
        return _asepy.EquidistantGrid_nCoords(self)

    def min(self) -> "double":
        return _asepy.EquidistantGrid_min(self)

    def max(self) -> "double":
        return _asepy.EquidistantGrid_max(self)

    def getInterval(self, coordinate: "double") -> "std::pair< unsigned int,double >":
        return _asepy.EquidistantGrid_getInterval(self, coordinate)

    def coords(self) -> "std::vector< double,std::allocator< double > >":
        return _asepy.EquidistantGrid_coords(self)

    def coordinate(self, i: "unsigned int") -> "double":
        return _asepy.EquidistantGrid_coordinate(self, i)

    def length(self) -> "double":
        return _asepy.EquidistantGrid_length(self)

    def isUniform(self) -> "bool":
        return _asepy.EquidistantGrid_isUniform(self)

    def nIntervals(self) -> "unsigned int":
        return _asepy.EquidistantGrid_nIntervals(self)

    def intervalWidth(self, *args) -> "double":
        return _asepy.EquidistantGrid_intervalWidth(self, *args)
    __swig_destroy__ = _asepy.delete_EquidistantGrid

# Register EquidistantGrid in _asepy:
_asepy.EquidistantGrid_swigregister(EquidistantGrid)


def kullbackLeiblerDivergence(*args) -> "double":
    return _asepy.kullbackLeiblerDivergence(*args)
class GaussLegendreQuadrature(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, npoints: "unsigned int"):
        _asepy.GaussLegendreQuadrature_swiginit(self, _asepy.new_GaussLegendreQuadrature(npoints))
    __swig_destroy__ = _asepy.delete_GaussLegendreQuadrature

    def npoints(self) -> "unsigned int":
        return _asepy.GaussLegendreQuadrature_npoints(self)

    @staticmethod
    def isAllowed(npoints: "unsigned int") -> "bool":
        return _asepy.GaussLegendreQuadrature_isAllowed(npoints)

    @staticmethod
    def allowedNPonts() -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        return _asepy.GaussLegendreQuadrature_allowedNPonts()

    @staticmethod
    def minimalExactRule(polyDegree: "unsigned int") -> "unsigned int":
        return _asepy.GaussLegendreQuadrature_minimalExactRule(polyDegree)

    def integrate(self, *args) -> "double":
        return _asepy.GaussLegendreQuadrature_integrate(self, *args)

# Register GaussLegendreQuadrature in _asepy:
_asepy.GaussLegendreQuadrature_swigregister(GaussLegendreQuadrature)

def GaussLegendreQuadrature_isAllowed(npoints: "unsigned int") -> "bool":
    return _asepy.GaussLegendreQuadrature_isAllowed(npoints)

def GaussLegendreQuadrature_allowedNPonts() -> "std::vector< unsigned int,std::allocator< unsigned int > >":
    return _asepy.GaussLegendreQuadrature_allowedNPonts()

def GaussLegendreQuadrature_minimalExactRule(polyDegree: "unsigned int") -> "unsigned int":
    return _asepy.GaussLegendreQuadrature_minimalExactRule(polyDegree)

class DiscretizedConvolution(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m1: "AbsDistributionModel1D", m2: "AbsDistributionModel1D", xmin: "double", xmax: "double", nIntervals: "unsigned int", normalize: "bool"=False):
        _asepy.DiscretizedConvolution_swiginit(self, _asepy.new_DiscretizedConvolution(m1, m2, xmin, xmax, nIntervals, normalize))

    def normalize(self) -> "void":
        return _asepy.DiscretizedConvolution_normalize(self)

    def __call__(self, x: "double") -> "double":
        return _asepy.DiscretizedConvolution___call__(self, x)

    def densityIntegral(self) -> "double":
        return _asepy.DiscretizedConvolution_densityIntegral(self)

    def xmin(self) -> "double":
        return _asepy.DiscretizedConvolution_xmin(self)

    def xmax(self) -> "double":
        return _asepy.DiscretizedConvolution_xmax(self)

    def nIntervals(self) -> "unsigned int":
        return _asepy.DiscretizedConvolution_nIntervals(self)

    def intervalWidth(self) -> "double":
        return _asepy.DiscretizedConvolution_intervalWidth(self)

    def isNormalized(self) -> "bool":
        return _asepy.DiscretizedConvolution_isNormalized(self)

    def convolvedValue(self, i: "unsigned int const") -> "double":
        return _asepy.DiscretizedConvolution_convolvedValue(self, i)

    def coordinateAt(self, i: "unsigned int") -> "double":
        return _asepy.DiscretizedConvolution_coordinateAt(self, i)

    def constructTabulatedDensity(self) -> "ase::TabulatedDensity1D":
        return _asepy.DiscretizedConvolution_constructTabulatedDensity(self)

    def constructInterpolatedDensity(self) -> "ase::InterpolatedDensity1D":
        return _asepy.DiscretizedConvolution_constructInterpolatedDensity(self)
    __swig_destroy__ = _asepy.delete_DiscretizedConvolution

# Register DiscretizedConvolution in _asepy:
_asepy.DiscretizedConvolution_swigregister(DiscretizedConvolution)

GCDF16 = _asepy.GCDF16
GCDF84 = _asepy.GCDF84
class TruncatedDistribution1D(AbsDistributionModel1D):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.TruncatedDistribution1D_isFullOPAT

    def __init__(self, distro: "AbsDistributionModel1D", xmin: "double", xmax: "double"):
        _asepy.TruncatedDistribution1D_swiginit(self, _asepy.new_TruncatedDistribution1D(distro, xmin, xmax))

    def clone(self) -> "ase::TruncatedDistribution1D *":
        return _asepy.TruncatedDistribution1D_clone(self)
    __swig_destroy__ = _asepy.delete_TruncatedDistribution1D

    def density(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_density(self, x)

    def isDensityContinuous(self) -> "bool":
        return _asepy.TruncatedDistribution1D_isDensityContinuous(self)

    def isNonNegative(self) -> "bool":
        return _asepy.TruncatedDistribution1D_isNonNegative(self)

    def isUnimodal(self) -> "bool":
        return _asepy.TruncatedDistribution1D_isUnimodal(self)

    def densityDerivative(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_densityDerivative(self, x)

    def cdf(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_cdf(self, x)

    def exceedance(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_exceedance(self, x)

    def quantile(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_quantile(self, x)

    def invExceedance(self, x: "double") -> "double":
        return _asepy.TruncatedDistribution1D_invExceedance(self, x)

    def cumulant(self, n: "unsigned int") -> "double":
        return _asepy.TruncatedDistribution1D_cumulant(self, n)

    def mode(self) -> "double":
        return _asepy.TruncatedDistribution1D_mode(self)

    def descentDelta(self, isToTheRight: "bool", deltaLnL: "double"=0.5) -> "double":
        return _asepy.TruncatedDistribution1D_descentDelta(self, isToTheRight, deltaLnL)

    def classname(self) -> "std::string":
        return _asepy.TruncatedDistribution1D_classname(self)

# Register TruncatedDistribution1D in _asepy:
_asepy.TruncatedDistribution1D_swigregister(TruncatedDistribution1D)

OPEN_INTERVAL = _asepy.OPEN_INTERVAL
CLOSED_INTERVAL = _asepy.CLOSED_INTERVAL
LEFT_CLOSED_INTERVAL = _asepy.LEFT_CLOSED_INTERVAL
RIGHT_CLOSED_INTERVAL = _asepy.RIGHT_CLOSED_INTERVAL
RIGHT_OPEN_INTERVAL = _asepy.RIGHT_OPEN_INTERVAL
LEFT_OPEN_INTERVAL = _asepy.LEFT_OPEN_INTERVAL
class Interval(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.Interval_swiginit(self, _asepy.new_Interval(*args))

    def min(self) -> "double":
        return _asepy.Interval_min(self)

    def max(self) -> "double":
        return _asepy.Interval_max(self)

    def type(self) -> "ase::IntervalType":
        return _asepy.Interval_type(self)

    def length(self) -> "double":
        return _asepy.Interval_length(self)

    def midpoint(self) -> "double":
        return _asepy.Interval_midpoint(self)

    def empty(self) -> "bool":
        return _asepy.Interval_empty(self)

    def includesLeft(self) -> "bool":
        return _asepy.Interval_includesLeft(self)

    def includesRight(self) -> "bool":
        return _asepy.Interval_includesRight(self)

    def contains(self, *args) -> "bool":
        return _asepy.Interval_contains(self, *args)

    def distance(self, x: "double const") -> "double":
        return _asepy.Interval_distance(self, x)

    def overlap(self, r: "Interval") -> "ase::Interval< double >":
        return _asepy.Interval_overlap(self, r)

    @staticmethod
    def fromInclusions(includeLeft: "bool const", includeRight: "bool const") -> "ase::IntervalType":
        return _asepy.Interval_fromInclusions(includeLeft, includeRight)
    __swig_destroy__ = _asepy.delete_Interval

# Register Interval in _asepy:
_asepy.Interval_swigregister(Interval)

def Interval_fromInclusions(includeLeft: "bool const", includeRight: "bool const") -> "ase::IntervalType":
    return _asepy.Interval_fromInclusions(includeLeft, includeRight)

class MixtureModel1D(AbsDistributionModel1D):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    isFullOPAT = _asepy.MixtureModel1D_isFullOPAT

    def __init__(self):
        _asepy.MixtureModel1D_swiginit(self, _asepy.new_MixtureModel1D())

    def clone(self) -> "ase::MixtureModel1D *":
        return _asepy.MixtureModel1D_clone(self)
    __swig_destroy__ = _asepy.delete_MixtureModel1D

    def add(self, distro: "AbsDistributionModel1D", weight: "double") -> "ase::MixtureModel1D &":
        return _asepy.MixtureModel1D_add(self, distro, weight)

    def nComponents(self) -> "unsigned int":
        return _asepy.MixtureModel1D_nComponents(self)

    def getComponent(self, n: "unsigned int const") -> "ase::AbsDistributionModel1D const &":
        return _asepy.MixtureModel1D_getComponent(self, n)

    def getWeight(self, n: "unsigned int") -> "double":
        return _asepy.MixtureModel1D_getWeight(self, n)

    def density(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_density(self, x)

    def isDensityContinuous(self) -> "bool":
        return _asepy.MixtureModel1D_isDensityContinuous(self)

    def isUnimodal(self) -> "bool":
        return _asepy.MixtureModel1D_isUnimodal(self)

    def densityDerivative(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_densityDerivative(self, x)

    def cdf(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_cdf(self, x)

    def exceedance(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_exceedance(self, x)

    def quantile(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_quantile(self, x)

    def invExceedance(self, x: "double") -> "double":
        return _asepy.MixtureModel1D_invExceedance(self, x)

    def cumulant(self, n: "unsigned int") -> "double":
        return _asepy.MixtureModel1D_cumulant(self, n)

    def mode(self) -> "double":
        return _asepy.MixtureModel1D_mode(self)

    def descentDelta(self, isToTheRight: "bool", deltaLnL: "double"=0.5) -> "double":
        return _asepy.MixtureModel1D_descentDelta(self, isToTheRight, deltaLnL)

    def random(self, gen: "AbsRNG") -> "double":
        return _asepy.MixtureModel1D_random(self, gen)

    def classname(self) -> "std::string":
        return _asepy.MixtureModel1D_classname(self)

# Register MixtureModel1D in _asepy:
_asepy.MixtureModel1D_swigregister(MixtureModel1D)

class DoubleFunctor1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "double (*)(double)"):
        _asepy.DoubleFunctor1_swiginit(self, _asepy.new_DoubleFunctor1(fcn))

    def __call__(self, x: "double const") -> "double":
        return _asepy.DoubleFunctor1___call__(self, x)
    __swig_destroy__ = _asepy.delete_DoubleFunctor1

# Register DoubleFunctor1 in _asepy:
_asepy.DoubleFunctor1_swigregister(DoubleFunctor1)

class LongDoubleFunctor1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fcn: "long double (*)(long double)"):
        _asepy.LongDoubleFunctor1_swiginit(self, _asepy.new_LongDoubleFunctor1(fcn))

    def __call__(self, x: "long double const") -> "long double":
        return _asepy.LongDoubleFunctor1___call__(self, x)
    __swig_destroy__ = _asepy.delete_LongDoubleFunctor1

# Register LongDoubleFunctor1 in _asepy:
_asepy.LongDoubleFunctor1_swigregister(LongDoubleFunctor1)

P = _asepy.P
L = _asepy.L
N_ERROR_TYPES = _asepy.N_ERROR_TYPES
class AsymmetricEstimate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, centralValue: "double", sigmaPlus: "double", sigmaMinus: "double", errorType: "ase::ErrorType"):
        _asepy.AsymmetricEstimate_swiginit(self, _asepy.new_AsymmetricEstimate(centralValue, sigmaPlus, sigmaMinus, errorType))

    def location(self) -> "double":
        return _asepy.AsymmetricEstimate_location(self)

    def sigmaPlus(self) -> "double":
        return _asepy.AsymmetricEstimate_sigmaPlus(self)

    def sigmaMinus(self) -> "double":
        return _asepy.AsymmetricEstimate_sigmaMinus(self)

    def errorType(self) -> "ase::ErrorType":
        return _asepy.AsymmetricEstimate_errorType(self)

    def intervalEstimate(self) -> "ase::Interval< double >":
        return _asepy.AsymmetricEstimate_intervalEstimate(self)

    def width(self) -> "double":
        return _asepy.AsymmetricEstimate_width(self)

    def asymmetry(self) -> "double":
        return _asepy.AsymmetricEstimate_asymmetry(self)

    def __neg__(self) -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___neg__(self)

    def __pos__(self) -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___pos__(self)

    def __repr__(self) -> "std::string":
        return _asepy.AsymmetricEstimate___repr__(self)

    def __eq__(self, other: "AsymmetricEstimate") -> "bool":
        return _asepy.AsymmetricEstimate___eq__(self, other)

    def __ne__(self, other: "AsymmetricEstimate") -> "bool":
        return _asepy.AsymmetricEstimate___ne__(self, other)

    def __mul__(self, r: "double const &") -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___mul__(self, r)

    def __rmul__(self, r: "double const &") -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___rmul__(self, r)

    def __add__(self, r: "double const &") -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___add__(self, r)

    def __radd__(self, r: "double const &") -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___radd__(self, r)

    def __sub__(self, r: "double const &") -> "ase::AsymmetricEstimate":
        return _asepy.AsymmetricEstimate___sub__(self, r)

    def fstr(self, formatSpecifier):
        fmt = "{{{!s}}} + {{{!s}}} - {{{!s}}}".format(
            formatSpecifier, formatSpecifier, formatSpecifier)
        return fmt.format(self.location(), self.sigmaPlus(), self.sigmaMinus())

    # I had problems wrapping __truediv__ and __rsub__ with swig
    def __truediv__(self, other):
        if (other == 0.0):
            raise ZeroDivisionError("AsymmetricEstimate divided by zero")
        return self * (1.0/other)

    def __rsub__(self, other):
        return self * (-1.0) + other

    __swig_destroy__ = _asepy.delete_AsymmetricEstimate

# Register AsymmetricEstimate in _asepy:
_asepy.AsymmetricEstimate_swigregister(AsymmetricEstimate)


def parseAsymmetricEstimate(line: "string") -> "ase::AsymmetricEstimate":
    return _asepy.parseAsymmetricEstimate(line)

def readAsymmetricEstimates(filename: "string") -> "std::vector< ase::AsymmetricEstimate,std::allocator< ase::AsymmetricEstimate > >":
    return _asepy.readAsymmetricEstimates(filename)
class DistributionModel1DCopy(AbsDistributionModel1D):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _asepy.DistributionModel1DCopy_swiginit(self, _asepy.new_DistributionModel1DCopy(*args))

    def clone(self) -> "ase::DistributionModel1DCopy *":
        return _asepy.DistributionModel1DCopy_clone(self)
    __swig_destroy__ = _asepy.delete_DistributionModel1DCopy

    def theCopy(self) -> "ase::AbsDistributionModel1D const &":
        return _asepy.DistributionModel1DCopy_theCopy(self)

    def density(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_density(self, x)

    def isDensityContinuous(self) -> "bool":
        return _asepy.DistributionModel1DCopy_isDensityContinuous(self)

    def isNonNegative(self) -> "bool":
        return _asepy.DistributionModel1DCopy_isNonNegative(self)

    def isUnimodal(self) -> "bool":
        return _asepy.DistributionModel1DCopy_isUnimodal(self)

    def densityDerivative(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_densityDerivative(self, x)

    def cdf(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_cdf(self, x)

    def exceedance(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_exceedance(self, x)

    def quantile(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_quantile(self, x)

    def invExceedance(self, x: "double const") -> "double":
        return _asepy.DistributionModel1DCopy_invExceedance(self, x)

    def cumulant(self, n: "unsigned int const") -> "double":
        return _asepy.DistributionModel1DCopy_cumulant(self, n)

    def mode(self) -> "double":
        return _asepy.DistributionModel1DCopy_mode(self)

    def descentDelta(self, isToTheRight: "bool const", deltaLnL: "double const"=0.5) -> "double":
        return _asepy.DistributionModel1DCopy_descentDelta(self, isToTheRight, deltaLnL)

    def classname(self) -> "std::string":
        return _asepy.DistributionModel1DCopy_classname(self)

    def random(self, gen: "AbsRNG") -> "double":
        return _asepy.DistributionModel1DCopy_random(self, gen)

    def qWidth(self) -> "double":
        return _asepy.DistributionModel1DCopy_qWidth(self)

    def qAsymmetry(self) -> "double":
        return _asepy.DistributionModel1DCopy_qAsymmetry(self)

# Register DistributionModel1DCopy in _asepy:
_asepy.DistributionModel1DCopy_swigregister(DistributionModel1DCopy)


def getSeed(seed0: "unsigned long") -> "unsigned long":
    return _asepy.getSeed(seed0)
class DRand48(AbsRNG):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _asepy.delete_DRand48

    def __call__(self) -> "double":
        return _asepy.DRand48___call__(self)

    def __init__(self):
        _asepy.DRand48_swiginit(self, _asepy.new_DRand48())

# Register DRand48 in _asepy:
_asepy.DRand48_swigregister(DRand48)

class MersenneTwister32(AbsRNG):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, seed: "unsigned long const"=0):
        _asepy.MersenneTwister32_swiginit(self, _asepy.new_MersenneTwister32(seed))
    __swig_destroy__ = _asepy.delete_MersenneTwister32

    def __call__(self) -> "double":
        return _asepy.MersenneTwister32___call__(self)

# Register MersenneTwister32 in _asepy:
_asepy.MersenneTwister32_swigregister(MersenneTwister32)

class MersenneTwister64(AbsRNG):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, seed: "unsigned long const"=0):
        _asepy.MersenneTwister64_swiginit(self, _asepy.new_MersenneTwister64(seed))
    __swig_destroy__ = _asepy.delete_MersenneTwister64

    def __call__(self) -> "double":
        return _asepy.MersenneTwister64___call__(self)

# Register MersenneTwister64 in _asepy:
_asepy.MersenneTwister64_swigregister(MersenneTwister64)


def scanFunctor1D(*args) -> "PyObject *":
    return _asepy.scanFunctor1D(*args)

def empiricalCdfOutline(ed: "EmpiricalDistribution", xmin: "double const", xmax: "double const") -> "PyObject *":
    return _asepy.empiricalCdfOutline(ed, xmin, xmax)


